#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Jul  9 15:09:01 2017 by generateDS.py version 2.28a.
#
# Command line options:
#   ('-o', 'api.py')
#   ('-s', 'api_subs.py')
#   ('--super', 'api')
#   ('-f', '')
#
# Command line arguments:
#   pain.001.001.03.xsd
#
# Command line:
#   /usr/local/bin/generateDS -o "api.py" -s "api_subs.py" --super="api" -f pain.001.001.03.xsd
#
# Current working directory (os.getcwd()):
#   iso_api
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AccountIdentification4Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IBAN=None, Othr=None):
        self.original_tagname_ = None
        self.IBAN = IBAN
        self.validate_IBAN2007Identifier(self.IBAN)
        self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountIdentification4Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountIdentification4Choice.subclass:
            return AccountIdentification4Choice.subclass(*args_, **kwargs_)
        else:
            return AccountIdentification4Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IBAN(self): return self.IBAN
    def set_IBAN(self, IBAN): self.IBAN = IBAN
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_IBAN2007Identifier(self, value):
        # Validate type IBAN2007Identifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IBAN2007Identifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IBAN2007Identifier_patterns_, ))
    validate_IBAN2007Identifier_patterns_ = [['^[A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}$']]
    def hasContent_(self):
        if (
            self.IBAN is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountIdentification4Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountIdentification4Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountIdentification4Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountIdentification4Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountIdentification4Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccountIdentification4Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IBAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIBAN>%s</%sIBAN>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IBAN), input_name='IBAN')), namespace_, eol_))
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IBAN':
            IBAN_ = child_.text
            IBAN_ = self.gds_validate_string(IBAN_, node, 'IBAN')
            self.IBAN = IBAN_
            # validate type IBAN2007Identifier
            self.validate_IBAN2007Identifier(self.IBAN)
        elif nodeName_ == 'Othr':
            obj_ = GenericAccountIdentification1.factory()
            obj_.build(child_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class AccountIdentification4Choice


class AccountSchemeName1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalAccountIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountSchemeName1Choice.subclass:
            return AccountSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return AccountSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalAccountIdentification1Code(self, value):
        # Validate type ExternalAccountIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalAccountIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalAccountIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountSchemeName1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountSchemeName1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountSchemeName1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccountSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalAccountIdentification1Code
            self.validate_ExternalAccountIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class AccountSchemeName1Choice


class ActiveOrHistoricCurrencyAndAmount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Ccy=None, valueOf_=None):
        self.original_tagname_ = None
        self.Ccy = _cast(None, Ccy)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveOrHistoricCurrencyAndAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveOrHistoricCurrencyAndAmount.subclass:
            return ActiveOrHistoricCurrencyAndAmount.subclass(*args_, **kwargs_)
        else:
            return ActiveOrHistoricCurrencyAndAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ccy(self): return self.Ccy
    def set_Ccy(self, Ccy): self.Ccy = Ccy
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^[A-Z]{3,3}$']]
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveOrHistoricCurrencyAndAmount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveOrHistoricCurrencyAndAmount')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount'):
        if self.Ccy is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            outfile.write(' Ccy=%s' % (quote_attrib(self.Ccy), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveOrHistoricCurrencyAndAmount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ccy', node)
        if value is not None and 'Ccy' not in already_processed:
            already_processed.add('Ccy')
            self.Ccy = value
            self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)    # validate type ActiveOrHistoricCurrencyCode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActiveOrHistoricCurrencyAndAmount


class AmountType3Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InstdAmt=None, EqvtAmt=None):
        self.original_tagname_ = None
        self.InstdAmt = InstdAmt
        self.EqvtAmt = EqvtAmt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountType3Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountType3Choice.subclass:
            return AmountType3Choice.subclass(*args_, **kwargs_)
        else:
            return AmountType3Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InstdAmt(self): return self.InstdAmt
    def set_InstdAmt(self, InstdAmt): self.InstdAmt = InstdAmt
    def get_EqvtAmt(self): return self.EqvtAmt
    def set_EqvtAmt(self, EqvtAmt): self.EqvtAmt = EqvtAmt
    def hasContent_(self):
        if (
            self.InstdAmt is not None or
            self.EqvtAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountType3Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AmountType3Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountType3Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountType3Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountType3Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AmountType3Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstdAmt is not None:
            self.InstdAmt.export(outfile, level, namespace_, name_='InstdAmt', pretty_print=pretty_print)
        if self.EqvtAmt is not None:
            self.EqvtAmt.export(outfile, level, namespace_, name_='EqvtAmt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.InstdAmt = obj_
            obj_.original_tagname_ = 'InstdAmt'
        elif nodeName_ == 'EqvtAmt':
            obj_ = EquivalentAmount2.factory()
            obj_.build(child_)
            self.EqvtAmt = obj_
            obj_.original_tagname_ = 'EqvtAmt'
# end class AmountType3Choice


class Authorisation1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_Authorisation1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max128Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Authorisation1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Authorisation1Choice.subclass:
            return Authorisation1Choice.subclass(*args_, **kwargs_)
        else:
            return Authorisation1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_Authorisation1Code(self, value):
        # Validate type Authorisation1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AUTH', 'FDET', 'FSUM', 'ILEV']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Authorisation1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max128Text(self, value):
        # Validate type Max128Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 128:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max128Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max128Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Authorisation1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Authorisation1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Authorisation1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Authorisation1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Authorisation1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Authorisation1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type Authorisation1Code
            self.validate_Authorisation1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max128Text
            self.validate_Max128Text(self.Prtry)
# end class Authorisation1Choice


class BranchAndFinancialInstitutionIdentification4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinInstnId=None, BrnchId=None):
        self.original_tagname_ = None
        self.FinInstnId = FinInstnId
        self.BrnchId = BrnchId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchAndFinancialInstitutionIdentification4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchAndFinancialInstitutionIdentification4.subclass:
            return BranchAndFinancialInstitutionIdentification4.subclass(*args_, **kwargs_)
        else:
            return BranchAndFinancialInstitutionIdentification4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinInstnId(self): return self.FinInstnId
    def set_FinInstnId(self, FinInstnId): self.FinInstnId = FinInstnId
    def get_BrnchId(self): return self.BrnchId
    def set_BrnchId(self, BrnchId): self.BrnchId = BrnchId
    def hasContent_(self):
        if (
            self.FinInstnId is not None or
            self.BrnchId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BranchAndFinancialInstitutionIdentification4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchAndFinancialInstitutionIdentification4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BranchAndFinancialInstitutionIdentification4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BranchAndFinancialInstitutionIdentification4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BranchAndFinancialInstitutionIdentification4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FinInstnId is not None:
            self.FinInstnId.export(outfile, level, namespace_, name_='FinInstnId', pretty_print=pretty_print)
        if self.BrnchId is not None:
            self.BrnchId.export(outfile, level, namespace_, name_='BrnchId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinInstnId':
            obj_ = FinancialInstitutionIdentification7.factory()
            obj_.build(child_)
            self.FinInstnId = obj_
            obj_.original_tagname_ = 'FinInstnId'
        elif nodeName_ == 'BrnchId':
            obj_ = BranchData2.factory()
            obj_.build(child_)
            self.BrnchId = obj_
            obj_.original_tagname_ = 'BrnchId'
# end class BranchAndFinancialInstitutionIdentification4


class BranchData2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Nm=None, PstlAdr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PstlAdr = PstlAdr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BranchData2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BranchData2.subclass:
            return BranchData2.subclass(*args_, **kwargs_)
        else:
            return BranchData2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Nm is not None or
            self.PstlAdr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BranchData2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BranchData2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchData2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BranchData2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BranchData2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BranchData2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespace_, eol_))
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
# end class BranchData2


class CashAccount16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Tp=None, Ccy=None, Nm=None):
        self.original_tagname_ = None
        self.Id = Id
        self.Tp = Tp
        self.Ccy = Ccy
        self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
        self.Nm = Nm
        self.validate_Max70Text(self.Nm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccount16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccount16.subclass:
            return CashAccount16.subclass(*args_, **kwargs_)
        else:
            return CashAccount16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Ccy(self): return self.Ccy
    def set_Ccy(self, Ccy): self.Ccy = Ccy
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^[A-Z]{3,3}$']]
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Tp is not None or
            self.Ccy is not None or
            self.Nm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashAccount16', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CashAccount16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashAccount16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashAccount16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashAccount16'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CashAccount16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.Tp is not None:
            self.Tp.export(outfile, level, namespace_, name_='Tp', pretty_print=pretty_print)
        if self.Ccy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCcy>%s</%sCcy>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ccy), input_name='Ccy')), namespace_, eol_))
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            obj_ = AccountIdentification4Choice.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Tp':
            obj_ = CashAccountType2.factory()
            obj_.build(child_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Ccy':
            Ccy_ = child_.text
            Ccy_ = self.gds_validate_string(Ccy_, node, 'Ccy')
            self.Ccy = Ccy_
            # validate type ActiveOrHistoricCurrencyCode
            self.validate_ActiveOrHistoricCurrencyCode(self.Ccy)
        elif nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max70Text
            self.validate_Max70Text(self.Nm)
# end class CashAccount16


class CashAccountType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_CashAccountType4Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashAccountType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashAccountType2.subclass:
            return CashAccountType2.subclass(*args_, **kwargs_)
        else:
            return CashAccountType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_CashAccountType4Code(self, value):
        # Validate type CashAccountType4Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CASH', 'CHAR', 'COMM', 'TAXE', 'CISH', 'TRAS', 'SACC', 'CACC', 'SVGS', 'ONDP', 'MGLD', 'NREX', 'MOMA', 'LOAN', 'SLRY', 'ODFT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CashAccountType4Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashAccountType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CashAccountType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashAccountType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashAccountType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashAccountType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CashAccountType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type CashAccountType4Code
            self.validate_CashAccountType4Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CashAccountType2


class CategoryPurpose1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalCategoryPurpose1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryPurpose1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryPurpose1Choice.subclass:
            return CategoryPurpose1Choice.subclass(*args_, **kwargs_)
        else:
            return CategoryPurpose1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalCategoryPurpose1Code(self, value):
        # Validate type ExternalCategoryPurpose1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalCategoryPurpose1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalCategoryPurpose1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CategoryPurpose1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CategoryPurpose1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryPurpose1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CategoryPurpose1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CategoryPurpose1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CategoryPurpose1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalCategoryPurpose1Code
            self.validate_ExternalCategoryPurpose1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CategoryPurpose1Choice


class Cheque6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChqTp=None, ChqNb=None, ChqFr=None, DlvryMtd=None, DlvrTo=None, InstrPrty=None, ChqMtrtyDt=None, FrmsCd=None, MemoFld=None, RgnlClrZone=None, PrtLctn=None):
        self.original_tagname_ = None
        self.ChqTp = ChqTp
        self.validate_ChequeType2Code(self.ChqTp)
        self.ChqNb = ChqNb
        self.validate_Max35Text(self.ChqNb)
        self.ChqFr = ChqFr
        self.DlvryMtd = DlvryMtd
        self.DlvrTo = DlvrTo
        self.InstrPrty = InstrPrty
        self.validate_Priority2Code(self.InstrPrty)
        if isinstance(ChqMtrtyDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ChqMtrtyDt, '%Y-%m-%d').date()
        else:
            initvalue_ = ChqMtrtyDt
        self.ChqMtrtyDt = initvalue_
        self.FrmsCd = FrmsCd
        self.validate_Max35Text(self.FrmsCd)
        if MemoFld is None:
            self.MemoFld = []
        else:
            self.MemoFld = MemoFld
        self.RgnlClrZone = RgnlClrZone
        self.validate_Max35Text(self.RgnlClrZone)
        self.PrtLctn = PrtLctn
        self.validate_Max35Text(self.PrtLctn)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cheque6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cheque6.subclass:
            return Cheque6.subclass(*args_, **kwargs_)
        else:
            return Cheque6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChqTp(self): return self.ChqTp
    def set_ChqTp(self, ChqTp): self.ChqTp = ChqTp
    def get_ChqNb(self): return self.ChqNb
    def set_ChqNb(self, ChqNb): self.ChqNb = ChqNb
    def get_ChqFr(self): return self.ChqFr
    def set_ChqFr(self, ChqFr): self.ChqFr = ChqFr
    def get_DlvryMtd(self): return self.DlvryMtd
    def set_DlvryMtd(self, DlvryMtd): self.DlvryMtd = DlvryMtd
    def get_DlvrTo(self): return self.DlvrTo
    def set_DlvrTo(self, DlvrTo): self.DlvrTo = DlvrTo
    def get_InstrPrty(self): return self.InstrPrty
    def set_InstrPrty(self, InstrPrty): self.InstrPrty = InstrPrty
    def get_ChqMtrtyDt(self): return self.ChqMtrtyDt
    def set_ChqMtrtyDt(self, ChqMtrtyDt): self.ChqMtrtyDt = ChqMtrtyDt
    def get_FrmsCd(self): return self.FrmsCd
    def set_FrmsCd(self, FrmsCd): self.FrmsCd = FrmsCd
    def get_MemoFld(self): return self.MemoFld
    def set_MemoFld(self, MemoFld): self.MemoFld = MemoFld
    def add_MemoFld(self, value): self.MemoFld.append(value)
    def insert_MemoFld_at(self, index, value): self.MemoFld.insert(index, value)
    def replace_MemoFld_at(self, index, value): self.MemoFld[index] = value
    def get_RgnlClrZone(self): return self.RgnlClrZone
    def set_RgnlClrZone(self, RgnlClrZone): self.RgnlClrZone = RgnlClrZone
    def get_PrtLctn(self): return self.PrtLctn
    def set_PrtLctn(self, PrtLctn): self.PrtLctn = PrtLctn
    def validate_ChequeType2Code(self, value):
        # Validate type ChequeType2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CCHQ', 'CCCH', 'BCHQ', 'DRFT', 'ELDR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChequeType2Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_Priority2Code(self, value):
        # Validate type Priority2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HIGH', 'NORM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Priority2Code' % {"value" : value.encode("utf-8")} )
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.ChqTp is not None or
            self.ChqNb is not None or
            self.ChqFr is not None or
            self.DlvryMtd is not None or
            self.DlvrTo is not None or
            self.InstrPrty is not None or
            self.ChqMtrtyDt is not None or
            self.FrmsCd is not None or
            self.MemoFld or
            self.RgnlClrZone is not None or
            self.PrtLctn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cheque6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cheque6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cheque6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cheque6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cheque6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Cheque6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChqTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChqTp>%s</%sChqTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChqTp), input_name='ChqTp')), namespace_, eol_))
        if self.ChqNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChqNb>%s</%sChqNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChqNb), input_name='ChqNb')), namespace_, eol_))
        if self.ChqFr is not None:
            self.ChqFr.export(outfile, level, namespace_, name_='ChqFr', pretty_print=pretty_print)
        if self.DlvryMtd is not None:
            self.DlvryMtd.export(outfile, level, namespace_, name_='DlvryMtd', pretty_print=pretty_print)
        if self.DlvrTo is not None:
            self.DlvrTo.export(outfile, level, namespace_, name_='DlvrTo', pretty_print=pretty_print)
        if self.InstrPrty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrPrty>%s</%sInstrPrty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrPrty), input_name='InstrPrty')), namespace_, eol_))
        if self.ChqMtrtyDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChqMtrtyDt>%s</%sChqMtrtyDt>%s' % (namespace_, self.gds_format_date(self.ChqMtrtyDt, input_name='ChqMtrtyDt'), namespace_, eol_))
        if self.FrmsCd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFrmsCd>%s</%sFrmsCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FrmsCd), input_name='FrmsCd')), namespace_, eol_))
        for MemoFld_ in self.MemoFld:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMemoFld>%s</%sMemoFld>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MemoFld_), input_name='MemoFld')), namespace_, eol_))
        if self.RgnlClrZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRgnlClrZone>%s</%sRgnlClrZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RgnlClrZone), input_name='RgnlClrZone')), namespace_, eol_))
        if self.PrtLctn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtLctn>%s</%sPrtLctn>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrtLctn), input_name='PrtLctn')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChqTp':
            ChqTp_ = child_.text
            ChqTp_ = self.gds_validate_string(ChqTp_, node, 'ChqTp')
            self.ChqTp = ChqTp_
            # validate type ChequeType2Code
            self.validate_ChequeType2Code(self.ChqTp)
        elif nodeName_ == 'ChqNb':
            ChqNb_ = child_.text
            ChqNb_ = self.gds_validate_string(ChqNb_, node, 'ChqNb')
            self.ChqNb = ChqNb_
            # validate type Max35Text
            self.validate_Max35Text(self.ChqNb)
        elif nodeName_ == 'ChqFr':
            obj_ = NameAndAddress10.factory()
            obj_.build(child_)
            self.ChqFr = obj_
            obj_.original_tagname_ = 'ChqFr'
        elif nodeName_ == 'DlvryMtd':
            obj_ = ChequeDeliveryMethod1Choice.factory()
            obj_.build(child_)
            self.DlvryMtd = obj_
            obj_.original_tagname_ = 'DlvryMtd'
        elif nodeName_ == 'DlvrTo':
            obj_ = NameAndAddress10.factory()
            obj_.build(child_)
            self.DlvrTo = obj_
            obj_.original_tagname_ = 'DlvrTo'
        elif nodeName_ == 'InstrPrty':
            InstrPrty_ = child_.text
            InstrPrty_ = self.gds_validate_string(InstrPrty_, node, 'InstrPrty')
            self.InstrPrty = InstrPrty_
            # validate type Priority2Code
            self.validate_Priority2Code(self.InstrPrty)
        elif nodeName_ == 'ChqMtrtyDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ChqMtrtyDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.ChqMtrtyDt)
        elif nodeName_ == 'FrmsCd':
            FrmsCd_ = child_.text
            FrmsCd_ = self.gds_validate_string(FrmsCd_, node, 'FrmsCd')
            self.FrmsCd = FrmsCd_
            # validate type Max35Text
            self.validate_Max35Text(self.FrmsCd)
        elif nodeName_ == 'MemoFld':
            MemoFld_ = child_.text
            MemoFld_ = self.gds_validate_string(MemoFld_, node, 'MemoFld')
            self.MemoFld.append(MemoFld_)
            # validate type Max35Text
            self.validate_Max35Text(self.MemoFld[-1])
        elif nodeName_ == 'RgnlClrZone':
            RgnlClrZone_ = child_.text
            RgnlClrZone_ = self.gds_validate_string(RgnlClrZone_, node, 'RgnlClrZone')
            self.RgnlClrZone = RgnlClrZone_
            # validate type Max35Text
            self.validate_Max35Text(self.RgnlClrZone)
        elif nodeName_ == 'PrtLctn':
            PrtLctn_ = child_.text
            PrtLctn_ = self.gds_validate_string(PrtLctn_, node, 'PrtLctn')
            self.PrtLctn = PrtLctn_
            # validate type Max35Text
            self.validate_Max35Text(self.PrtLctn)
# end class Cheque6


class ChequeDeliveryMethod1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ChequeDelivery1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChequeDeliveryMethod1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChequeDeliveryMethod1Choice.subclass:
            return ChequeDeliveryMethod1Choice.subclass(*args_, **kwargs_)
        else:
            return ChequeDeliveryMethod1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ChequeDelivery1Code(self, value):
        # Validate type ChequeDelivery1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MLDB', 'MLCD', 'MLFA', 'CRDB', 'CRCD', 'CRFA', 'PUDB', 'PUCD', 'PUFA', 'RGDB', 'RGCD', 'RGFA']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChequeDelivery1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChequeDeliveryMethod1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChequeDeliveryMethod1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChequeDeliveryMethod1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChequeDeliveryMethod1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChequeDeliveryMethod1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChequeDeliveryMethod1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ChequeDelivery1Code
            self.validate_ChequeDelivery1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ChequeDeliveryMethod1Choice


class ClearingSystemIdentification2Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalClearingSystemIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingSystemIdentification2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingSystemIdentification2Choice.subclass:
            return ClearingSystemIdentification2Choice.subclass(*args_, **kwargs_)
        else:
            return ClearingSystemIdentification2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalClearingSystemIdentification1Code(self, value):
        # Validate type ExternalClearingSystemIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalClearingSystemIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalClearingSystemIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingSystemIdentification2Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClearingSystemIdentification2Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingSystemIdentification2Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingSystemIdentification2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingSystemIdentification2Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingSystemIdentification2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalClearingSystemIdentification1Code
            self.validate_ExternalClearingSystemIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ClearingSystemIdentification2Choice


class ClearingSystemMemberIdentification2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClrSysId=None, MmbId=None):
        self.original_tagname_ = None
        self.ClrSysId = ClrSysId
        self.MmbId = MmbId
        self.validate_Max35Text(self.MmbId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingSystemMemberIdentification2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingSystemMemberIdentification2.subclass:
            return ClearingSystemMemberIdentification2.subclass(*args_, **kwargs_)
        else:
            return ClearingSystemMemberIdentification2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClrSysId(self): return self.ClrSysId
    def set_ClrSysId(self, ClrSysId): self.ClrSysId = ClrSysId
    def get_MmbId(self): return self.MmbId
    def set_MmbId(self, MmbId): self.MmbId = MmbId
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClrSysId is not None or
            self.MmbId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingSystemMemberIdentification2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClearingSystemMemberIdentification2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingSystemMemberIdentification2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingSystemMemberIdentification2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingSystemMemberIdentification2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingSystemMemberIdentification2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClrSysId is not None:
            self.ClrSysId.export(outfile, level, namespace_, name_='ClrSysId', pretty_print=pretty_print)
        if self.MmbId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMmbId>%s</%sMmbId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MmbId), input_name='MmbId')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClrSysId':
            obj_ = ClearingSystemIdentification2Choice.factory()
            obj_.build(child_)
            self.ClrSysId = obj_
            obj_.original_tagname_ = 'ClrSysId'
        elif nodeName_ == 'MmbId':
            MmbId_ = child_.text
            MmbId_ = self.gds_validate_string(MmbId_, node, 'MmbId')
            self.MmbId = MmbId_
            # validate type Max35Text
            self.validate_Max35Text(self.MmbId)
# end class ClearingSystemMemberIdentification2


class ContactDetails2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NmPrfx=None, Nm=None, PhneNb=None, MobNb=None, FaxNb=None, EmailAdr=None, Othr=None):
        self.original_tagname_ = None
        self.NmPrfx = NmPrfx
        self.validate_NamePrefix1Code(self.NmPrfx)
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PhneNb = PhneNb
        self.validate_PhoneNumber(self.PhneNb)
        self.MobNb = MobNb
        self.validate_PhoneNumber(self.MobNb)
        self.FaxNb = FaxNb
        self.validate_PhoneNumber(self.FaxNb)
        self.EmailAdr = EmailAdr
        self.validate_Max2048Text(self.EmailAdr)
        self.Othr = Othr
        self.validate_Max35Text(self.Othr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactDetails2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactDetails2.subclass:
            return ContactDetails2.subclass(*args_, **kwargs_)
        else:
            return ContactDetails2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NmPrfx(self): return self.NmPrfx
    def set_NmPrfx(self, NmPrfx): self.NmPrfx = NmPrfx
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PhneNb(self): return self.PhneNb
    def set_PhneNb(self, PhneNb): self.PhneNb = PhneNb
    def get_MobNb(self): return self.MobNb
    def set_MobNb(self, MobNb): self.MobNb = MobNb
    def get_FaxNb(self): return self.FaxNb
    def set_FaxNb(self, FaxNb): self.FaxNb = FaxNb
    def get_EmailAdr(self): return self.EmailAdr
    def set_EmailAdr(self, EmailAdr): self.EmailAdr = EmailAdr
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_NamePrefix1Code(self, value):
        # Validate type NamePrefix1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DOCT', 'MIST', 'MISS', 'MADM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NamePrefix1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def validate_PhoneNumber(self, value):
        # Validate type PhoneNumber, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PhoneNumber_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PhoneNumber_patterns_, ))
    validate_PhoneNumber_patterns_ = [['^\\+[0-9]{1,3}-[0-9()+\\-]{1,30}$']]
    def validate_Max2048Text(self, value):
        # Validate type Max2048Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2048:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max2048Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max2048Text' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NmPrfx is not None or
            self.Nm is not None or
            self.PhneNb is not None or
            self.MobNb is not None or
            self.FaxNb is not None or
            self.EmailAdr is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContactDetails2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactDetails2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactDetails2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContactDetails2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactDetails2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactDetails2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NmPrfx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNmPrfx>%s</%sNmPrfx>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NmPrfx), input_name='NmPrfx')), namespace_, eol_))
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
        if self.PhneNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhneNb>%s</%sPhneNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PhneNb), input_name='PhneNb')), namespace_, eol_))
        if self.MobNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMobNb>%s</%sMobNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MobNb), input_name='MobNb')), namespace_, eol_))
        if self.FaxNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFaxNb>%s</%sFaxNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FaxNb), input_name='FaxNb')), namespace_, eol_))
        if self.EmailAdr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmailAdr>%s</%sEmailAdr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EmailAdr), input_name='EmailAdr')), namespace_, eol_))
        if self.Othr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOthr>%s</%sOthr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Othr), input_name='Othr')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NmPrfx':
            NmPrfx_ = child_.text
            NmPrfx_ = self.gds_validate_string(NmPrfx_, node, 'NmPrfx')
            self.NmPrfx = NmPrfx_
            # validate type NamePrefix1Code
            self.validate_NamePrefix1Code(self.NmPrfx)
        elif nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PhneNb':
            PhneNb_ = child_.text
            PhneNb_ = self.gds_validate_string(PhneNb_, node, 'PhneNb')
            self.PhneNb = PhneNb_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.PhneNb)
        elif nodeName_ == 'MobNb':
            MobNb_ = child_.text
            MobNb_ = self.gds_validate_string(MobNb_, node, 'MobNb')
            self.MobNb = MobNb_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.MobNb)
        elif nodeName_ == 'FaxNb':
            FaxNb_ = child_.text
            FaxNb_ = self.gds_validate_string(FaxNb_, node, 'FaxNb')
            self.FaxNb = FaxNb_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.FaxNb)
        elif nodeName_ == 'EmailAdr':
            EmailAdr_ = child_.text
            EmailAdr_ = self.gds_validate_string(EmailAdr_, node, 'EmailAdr')
            self.EmailAdr = EmailAdr_
            # validate type Max2048Text
            self.validate_Max2048Text(self.EmailAdr)
        elif nodeName_ == 'Othr':
            Othr_ = child_.text
            Othr_ = self.gds_validate_string(Othr_, node, 'Othr')
            self.Othr = Othr_
            # validate type Max35Text
            self.validate_Max35Text(self.Othr)
# end class ContactDetails2


class CreditTransferTransactionInformation10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PmtId=None, PmtTpInf=None, Amt=None, XchgRateInf=None, ChrgBr=None, ChqInstr=None, UltmtDbtr=None, IntrmyAgt1=None, IntrmyAgt1Acct=None, IntrmyAgt2=None, IntrmyAgt2Acct=None, IntrmyAgt3=None, IntrmyAgt3Acct=None, CdtrAgt=None, CdtrAgtAcct=None, Cdtr=None, CdtrAcct=None, UltmtCdtr=None, InstrForCdtrAgt=None, InstrForDbtrAgt=None, Purp=None, RgltryRptg=None, Tax=None, RltdRmtInf=None, RmtInf=None):
        self.original_tagname_ = None
        self.PmtId = PmtId
        self.PmtTpInf = PmtTpInf
        self.Amt = Amt
        self.XchgRateInf = XchgRateInf
        self.ChrgBr = ChrgBr
        self.validate_ChargeBearerType1Code(self.ChrgBr)
        self.ChqInstr = ChqInstr
        self.UltmtDbtr = UltmtDbtr
        self.IntrmyAgt1 = IntrmyAgt1
        self.IntrmyAgt1Acct = IntrmyAgt1Acct
        self.IntrmyAgt2 = IntrmyAgt2
        self.IntrmyAgt2Acct = IntrmyAgt2Acct
        self.IntrmyAgt3 = IntrmyAgt3
        self.IntrmyAgt3Acct = IntrmyAgt3Acct
        self.CdtrAgt = CdtrAgt
        self.CdtrAgtAcct = CdtrAgtAcct
        self.Cdtr = Cdtr
        self.CdtrAcct = CdtrAcct
        self.UltmtCdtr = UltmtCdtr
        if InstrForCdtrAgt is None:
            self.InstrForCdtrAgt = []
        else:
            self.InstrForCdtrAgt = InstrForCdtrAgt
        self.InstrForDbtrAgt = InstrForDbtrAgt
        self.validate_Max140Text(self.InstrForDbtrAgt)
        self.Purp = Purp
        if RgltryRptg is None:
            self.RgltryRptg = []
        else:
            self.RgltryRptg = RgltryRptg
        self.Tax = Tax
        if RltdRmtInf is None:
            self.RltdRmtInf = []
        else:
            self.RltdRmtInf = RltdRmtInf
        self.RmtInf = RmtInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditTransferTransactionInformation10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditTransferTransactionInformation10.subclass:
            return CreditTransferTransactionInformation10.subclass(*args_, **kwargs_)
        else:
            return CreditTransferTransactionInformation10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PmtId(self): return self.PmtId
    def set_PmtId(self, PmtId): self.PmtId = PmtId
    def get_PmtTpInf(self): return self.PmtTpInf
    def set_PmtTpInf(self, PmtTpInf): self.PmtTpInf = PmtTpInf
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_XchgRateInf(self): return self.XchgRateInf
    def set_XchgRateInf(self, XchgRateInf): self.XchgRateInf = XchgRateInf
    def get_ChrgBr(self): return self.ChrgBr
    def set_ChrgBr(self, ChrgBr): self.ChrgBr = ChrgBr
    def get_ChqInstr(self): return self.ChqInstr
    def set_ChqInstr(self, ChqInstr): self.ChqInstr = ChqInstr
    def get_UltmtDbtr(self): return self.UltmtDbtr
    def set_UltmtDbtr(self, UltmtDbtr): self.UltmtDbtr = UltmtDbtr
    def get_IntrmyAgt1(self): return self.IntrmyAgt1
    def set_IntrmyAgt1(self, IntrmyAgt1): self.IntrmyAgt1 = IntrmyAgt1
    def get_IntrmyAgt1Acct(self): return self.IntrmyAgt1Acct
    def set_IntrmyAgt1Acct(self, IntrmyAgt1Acct): self.IntrmyAgt1Acct = IntrmyAgt1Acct
    def get_IntrmyAgt2(self): return self.IntrmyAgt2
    def set_IntrmyAgt2(self, IntrmyAgt2): self.IntrmyAgt2 = IntrmyAgt2
    def get_IntrmyAgt2Acct(self): return self.IntrmyAgt2Acct
    def set_IntrmyAgt2Acct(self, IntrmyAgt2Acct): self.IntrmyAgt2Acct = IntrmyAgt2Acct
    def get_IntrmyAgt3(self): return self.IntrmyAgt3
    def set_IntrmyAgt3(self, IntrmyAgt3): self.IntrmyAgt3 = IntrmyAgt3
    def get_IntrmyAgt3Acct(self): return self.IntrmyAgt3Acct
    def set_IntrmyAgt3Acct(self, IntrmyAgt3Acct): self.IntrmyAgt3Acct = IntrmyAgt3Acct
    def get_CdtrAgt(self): return self.CdtrAgt
    def set_CdtrAgt(self, CdtrAgt): self.CdtrAgt = CdtrAgt
    def get_CdtrAgtAcct(self): return self.CdtrAgtAcct
    def set_CdtrAgtAcct(self, CdtrAgtAcct): self.CdtrAgtAcct = CdtrAgtAcct
    def get_Cdtr(self): return self.Cdtr
    def set_Cdtr(self, Cdtr): self.Cdtr = Cdtr
    def get_CdtrAcct(self): return self.CdtrAcct
    def set_CdtrAcct(self, CdtrAcct): self.CdtrAcct = CdtrAcct
    def get_UltmtCdtr(self): return self.UltmtCdtr
    def set_UltmtCdtr(self, UltmtCdtr): self.UltmtCdtr = UltmtCdtr
    def get_InstrForCdtrAgt(self): return self.InstrForCdtrAgt
    def set_InstrForCdtrAgt(self, InstrForCdtrAgt): self.InstrForCdtrAgt = InstrForCdtrAgt
    def add_InstrForCdtrAgt(self, value): self.InstrForCdtrAgt.append(value)
    def insert_InstrForCdtrAgt_at(self, index, value): self.InstrForCdtrAgt.insert(index, value)
    def replace_InstrForCdtrAgt_at(self, index, value): self.InstrForCdtrAgt[index] = value
    def get_InstrForDbtrAgt(self): return self.InstrForDbtrAgt
    def set_InstrForDbtrAgt(self, InstrForDbtrAgt): self.InstrForDbtrAgt = InstrForDbtrAgt
    def get_Purp(self): return self.Purp
    def set_Purp(self, Purp): self.Purp = Purp
    def get_RgltryRptg(self): return self.RgltryRptg
    def set_RgltryRptg(self, RgltryRptg): self.RgltryRptg = RgltryRptg
    def add_RgltryRptg(self, value): self.RgltryRptg.append(value)
    def insert_RgltryRptg_at(self, index, value): self.RgltryRptg.insert(index, value)
    def replace_RgltryRptg_at(self, index, value): self.RgltryRptg[index] = value
    def get_Tax(self): return self.Tax
    def set_Tax(self, Tax): self.Tax = Tax
    def get_RltdRmtInf(self): return self.RltdRmtInf
    def set_RltdRmtInf(self, RltdRmtInf): self.RltdRmtInf = RltdRmtInf
    def add_RltdRmtInf(self, value): self.RltdRmtInf.append(value)
    def insert_RltdRmtInf_at(self, index, value): self.RltdRmtInf.insert(index, value)
    def replace_RltdRmtInf_at(self, index, value): self.RltdRmtInf[index] = value
    def get_RmtInf(self): return self.RmtInf
    def set_RmtInf(self, RmtInf): self.RmtInf = RmtInf
    def validate_ChargeBearerType1Code(self, value):
        # Validate type ChargeBearerType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEBT', 'CRED', 'SHAR', 'SLEV']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChargeBearerType1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PmtId is not None or
            self.PmtTpInf is not None or
            self.Amt is not None or
            self.XchgRateInf is not None or
            self.ChrgBr is not None or
            self.ChqInstr is not None or
            self.UltmtDbtr is not None or
            self.IntrmyAgt1 is not None or
            self.IntrmyAgt1Acct is not None or
            self.IntrmyAgt2 is not None or
            self.IntrmyAgt2Acct is not None or
            self.IntrmyAgt3 is not None or
            self.IntrmyAgt3Acct is not None or
            self.CdtrAgt is not None or
            self.CdtrAgtAcct is not None or
            self.Cdtr is not None or
            self.CdtrAcct is not None or
            self.UltmtCdtr is not None or
            self.InstrForCdtrAgt or
            self.InstrForDbtrAgt is not None or
            self.Purp is not None or
            self.RgltryRptg or
            self.Tax is not None or
            self.RltdRmtInf or
            self.RmtInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditTransferTransactionInformation10', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditTransferTransactionInformation10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditTransferTransactionInformation10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditTransferTransactionInformation10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditTransferTransactionInformation10'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditTransferTransactionInformation10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PmtId is not None:
            self.PmtId.export(outfile, level, namespace_, name_='PmtId', pretty_print=pretty_print)
        if self.PmtTpInf is not None:
            self.PmtTpInf.export(outfile, level, namespace_, name_='PmtTpInf', pretty_print=pretty_print)
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        if self.XchgRateInf is not None:
            self.XchgRateInf.export(outfile, level, namespace_, name_='XchgRateInf', pretty_print=pretty_print)
        if self.ChrgBr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChrgBr>%s</%sChrgBr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChrgBr), input_name='ChrgBr')), namespace_, eol_))
        if self.ChqInstr is not None:
            self.ChqInstr.export(outfile, level, namespace_, name_='ChqInstr', pretty_print=pretty_print)
        if self.UltmtDbtr is not None:
            self.UltmtDbtr.export(outfile, level, namespace_, name_='UltmtDbtr', pretty_print=pretty_print)
        if self.IntrmyAgt1 is not None:
            self.IntrmyAgt1.export(outfile, level, namespace_, name_='IntrmyAgt1', pretty_print=pretty_print)
        if self.IntrmyAgt1Acct is not None:
            self.IntrmyAgt1Acct.export(outfile, level, namespace_, name_='IntrmyAgt1Acct', pretty_print=pretty_print)
        if self.IntrmyAgt2 is not None:
            self.IntrmyAgt2.export(outfile, level, namespace_, name_='IntrmyAgt2', pretty_print=pretty_print)
        if self.IntrmyAgt2Acct is not None:
            self.IntrmyAgt2Acct.export(outfile, level, namespace_, name_='IntrmyAgt2Acct', pretty_print=pretty_print)
        if self.IntrmyAgt3 is not None:
            self.IntrmyAgt3.export(outfile, level, namespace_, name_='IntrmyAgt3', pretty_print=pretty_print)
        if self.IntrmyAgt3Acct is not None:
            self.IntrmyAgt3Acct.export(outfile, level, namespace_, name_='IntrmyAgt3Acct', pretty_print=pretty_print)
        if self.CdtrAgt is not None:
            self.CdtrAgt.export(outfile, level, namespace_, name_='CdtrAgt', pretty_print=pretty_print)
        if self.CdtrAgtAcct is not None:
            self.CdtrAgtAcct.export(outfile, level, namespace_, name_='CdtrAgtAcct', pretty_print=pretty_print)
        if self.Cdtr is not None:
            self.Cdtr.export(outfile, level, namespace_, name_='Cdtr', pretty_print=pretty_print)
        if self.CdtrAcct is not None:
            self.CdtrAcct.export(outfile, level, namespace_, name_='CdtrAcct', pretty_print=pretty_print)
        if self.UltmtCdtr is not None:
            self.UltmtCdtr.export(outfile, level, namespace_, name_='UltmtCdtr', pretty_print=pretty_print)
        for InstrForCdtrAgt_ in self.InstrForCdtrAgt:
            InstrForCdtrAgt_.export(outfile, level, namespace_, name_='InstrForCdtrAgt', pretty_print=pretty_print)
        if self.InstrForDbtrAgt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrForDbtrAgt>%s</%sInstrForDbtrAgt>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrForDbtrAgt), input_name='InstrForDbtrAgt')), namespace_, eol_))
        if self.Purp is not None:
            self.Purp.export(outfile, level, namespace_, name_='Purp', pretty_print=pretty_print)
        for RgltryRptg_ in self.RgltryRptg:
            RgltryRptg_.export(outfile, level, namespace_, name_='RgltryRptg', pretty_print=pretty_print)
        if self.Tax is not None:
            self.Tax.export(outfile, level, namespace_, name_='Tax', pretty_print=pretty_print)
        for RltdRmtInf_ in self.RltdRmtInf:
            RltdRmtInf_.export(outfile, level, namespace_, name_='RltdRmtInf', pretty_print=pretty_print)
        if self.RmtInf is not None:
            self.RmtInf.export(outfile, level, namespace_, name_='RmtInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PmtId':
            obj_ = PaymentIdentification1.factory()
            obj_.build(child_)
            self.PmtId = obj_
            obj_.original_tagname_ = 'PmtId'
        elif nodeName_ == 'PmtTpInf':
            obj_ = PaymentTypeInformation19.factory()
            obj_.build(child_)
            self.PmtTpInf = obj_
            obj_.original_tagname_ = 'PmtTpInf'
        elif nodeName_ == 'Amt':
            obj_ = AmountType3Choice.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'XchgRateInf':
            obj_ = ExchangeRateInformation1.factory()
            obj_.build(child_)
            self.XchgRateInf = obj_
            obj_.original_tagname_ = 'XchgRateInf'
        elif nodeName_ == 'ChrgBr':
            ChrgBr_ = child_.text
            ChrgBr_ = self.gds_validate_string(ChrgBr_, node, 'ChrgBr')
            self.ChrgBr = ChrgBr_
            # validate type ChargeBearerType1Code
            self.validate_ChargeBearerType1Code(self.ChrgBr)
        elif nodeName_ == 'ChqInstr':
            obj_ = Cheque6.factory()
            obj_.build(child_)
            self.ChqInstr = obj_
            obj_.original_tagname_ = 'ChqInstr'
        elif nodeName_ == 'UltmtDbtr':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.UltmtDbtr = obj_
            obj_.original_tagname_ = 'UltmtDbtr'
        elif nodeName_ == 'IntrmyAgt1':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.IntrmyAgt1 = obj_
            obj_.original_tagname_ = 'IntrmyAgt1'
        elif nodeName_ == 'IntrmyAgt1Acct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.IntrmyAgt1Acct = obj_
            obj_.original_tagname_ = 'IntrmyAgt1Acct'
        elif nodeName_ == 'IntrmyAgt2':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.IntrmyAgt2 = obj_
            obj_.original_tagname_ = 'IntrmyAgt2'
        elif nodeName_ == 'IntrmyAgt2Acct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.IntrmyAgt2Acct = obj_
            obj_.original_tagname_ = 'IntrmyAgt2Acct'
        elif nodeName_ == 'IntrmyAgt3':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.IntrmyAgt3 = obj_
            obj_.original_tagname_ = 'IntrmyAgt3'
        elif nodeName_ == 'IntrmyAgt3Acct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.IntrmyAgt3Acct = obj_
            obj_.original_tagname_ = 'IntrmyAgt3Acct'
        elif nodeName_ == 'CdtrAgt':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.CdtrAgt = obj_
            obj_.original_tagname_ = 'CdtrAgt'
        elif nodeName_ == 'CdtrAgtAcct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.CdtrAgtAcct = obj_
            obj_.original_tagname_ = 'CdtrAgtAcct'
        elif nodeName_ == 'Cdtr':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.Cdtr = obj_
            obj_.original_tagname_ = 'Cdtr'
        elif nodeName_ == 'CdtrAcct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.CdtrAcct = obj_
            obj_.original_tagname_ = 'CdtrAcct'
        elif nodeName_ == 'UltmtCdtr':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.UltmtCdtr = obj_
            obj_.original_tagname_ = 'UltmtCdtr'
        elif nodeName_ == 'InstrForCdtrAgt':
            obj_ = InstructionForCreditorAgent1.factory()
            obj_.build(child_)
            self.InstrForCdtrAgt.append(obj_)
            obj_.original_tagname_ = 'InstrForCdtrAgt'
        elif nodeName_ == 'InstrForDbtrAgt':
            InstrForDbtrAgt_ = child_.text
            InstrForDbtrAgt_ = self.gds_validate_string(InstrForDbtrAgt_, node, 'InstrForDbtrAgt')
            self.InstrForDbtrAgt = InstrForDbtrAgt_
            # validate type Max140Text
            self.validate_Max140Text(self.InstrForDbtrAgt)
        elif nodeName_ == 'Purp':
            obj_ = Purpose2Choice.factory()
            obj_.build(child_)
            self.Purp = obj_
            obj_.original_tagname_ = 'Purp'
        elif nodeName_ == 'RgltryRptg':
            obj_ = RegulatoryReporting3.factory()
            obj_.build(child_)
            self.RgltryRptg.append(obj_)
            obj_.original_tagname_ = 'RgltryRptg'
        elif nodeName_ == 'Tax':
            obj_ = TaxInformation3.factory()
            obj_.build(child_)
            self.Tax = obj_
            obj_.original_tagname_ = 'Tax'
        elif nodeName_ == 'RltdRmtInf':
            obj_ = RemittanceLocation2.factory()
            obj_.build(child_)
            self.RltdRmtInf.append(obj_)
            obj_.original_tagname_ = 'RltdRmtInf'
        elif nodeName_ == 'RmtInf':
            obj_ = RemittanceInformation5.factory()
            obj_.build(child_)
            self.RmtInf = obj_
            obj_.original_tagname_ = 'RmtInf'
# end class CreditTransferTransactionInformation10


class CreditorReferenceInformation2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Ref=None):
        self.original_tagname_ = None
        self.Tp = Tp
        self.Ref = Ref
        self.validate_Max35Text(self.Ref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceInformation2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceInformation2.subclass:
            return CreditorReferenceInformation2.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceInformation2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Ref(self): return self.Ref
    def set_Ref(self, Ref): self.Ref = Ref
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Tp is not None or
            self.Ref is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditorReferenceInformation2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditorReferenceInformation2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditorReferenceInformation2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditorReferenceInformation2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditorReferenceInformation2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditorReferenceInformation2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            self.Tp.export(outfile, level, namespace_, name_='Tp', pretty_print=pretty_print)
        if self.Ref is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRef>%s</%sRef>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ref), input_name='Ref')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tp':
            obj_ = CreditorReferenceType2.factory()
            obj_.build(child_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Ref':
            Ref_ = child_.text
            Ref_ = self.gds_validate_string(Ref_, node, 'Ref')
            self.Ref = Ref_
            # validate type Max35Text
            self.validate_Max35Text(self.Ref)
# end class CreditorReferenceInformation2


class CreditorReferenceType1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_DocumentType3Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceType1Choice.subclass:
            return CreditorReferenceType1Choice.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_DocumentType3Code(self, value):
        # Validate type DocumentType3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RADM', 'RPIN', 'FXDR', 'DISP', 'PUOR', 'SCOR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocumentType3Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditorReferenceType1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditorReferenceType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditorReferenceType1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditorReferenceType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditorReferenceType1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditorReferenceType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type DocumentType3Code
            self.validate_DocumentType3Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class CreditorReferenceType1Choice


class CreditorReferenceType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None):
        self.original_tagname_ = None
        self.CdOrPrtry = CdOrPrtry
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditorReferenceType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditorReferenceType2.subclass:
            return CreditorReferenceType2.subclass(*args_, **kwargs_)
        else:
            return CreditorReferenceType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CdOrPrtry(self): return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry): self.CdOrPrtry = CdOrPrtry
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditorReferenceType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditorReferenceType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditorReferenceType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditorReferenceType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditorReferenceType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditorReferenceType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            self.CdOrPrtry.export(outfile, level, namespace_, name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CdOrPrtry':
            obj_ = CreditorReferenceType1Choice.factory()
            obj_.build(child_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            Issr_ = child_.text
            Issr_ = self.gds_validate_string(Issr_, node, 'Issr')
            self.Issr = Issr_
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class CreditorReferenceType2


class CustomerCreditTransferInitiationV03(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GrpHdr=None, PmtInf=None):
        self.original_tagname_ = None
        self.GrpHdr = GrpHdr
        if PmtInf is None:
            self.PmtInf = []
        else:
            self.PmtInf = PmtInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerCreditTransferInitiationV03)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerCreditTransferInitiationV03.subclass:
            return CustomerCreditTransferInitiationV03.subclass(*args_, **kwargs_)
        else:
            return CustomerCreditTransferInitiationV03(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GrpHdr(self): return self.GrpHdr
    def set_GrpHdr(self, GrpHdr): self.GrpHdr = GrpHdr
    def get_PmtInf(self): return self.PmtInf
    def set_PmtInf(self, PmtInf): self.PmtInf = PmtInf
    def add_PmtInf(self, value): self.PmtInf.append(value)
    def insert_PmtInf_at(self, index, value): self.PmtInf.insert(index, value)
    def replace_PmtInf_at(self, index, value): self.PmtInf[index] = value
    def hasContent_(self):
        if (
            self.GrpHdr is not None or
            self.PmtInf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerCreditTransferInitiationV03', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerCreditTransferInitiationV03')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerCreditTransferInitiationV03')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerCreditTransferInitiationV03', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerCreditTransferInitiationV03'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerCreditTransferInitiationV03', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GrpHdr is not None:
            self.GrpHdr.export(outfile, level, namespace_, name_='GrpHdr', pretty_print=pretty_print)
        for PmtInf_ in self.PmtInf:
            PmtInf_.export(outfile, level, namespace_, name_='PmtInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GrpHdr':
            obj_ = GroupHeader32.factory()
            obj_.build(child_)
            self.GrpHdr = obj_
            obj_.original_tagname_ = 'GrpHdr'
        elif nodeName_ == 'PmtInf':
            obj_ = PaymentInstructionInformation3.factory()
            obj_.build(child_)
            self.PmtInf.append(obj_)
            obj_.original_tagname_ = 'PmtInf'
# end class CustomerCreditTransferInitiationV03


class DateAndPlaceOfBirth(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BirthDt=None, PrvcOfBirth=None, CityOfBirth=None, CtryOfBirth=None):
        self.original_tagname_ = None
        if isinstance(BirthDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(BirthDt, '%Y-%m-%d').date()
        else:
            initvalue_ = BirthDt
        self.BirthDt = initvalue_
        self.PrvcOfBirth = PrvcOfBirth
        self.validate_Max35Text(self.PrvcOfBirth)
        self.CityOfBirth = CityOfBirth
        self.validate_Max35Text(self.CityOfBirth)
        self.CtryOfBirth = CtryOfBirth
        self.validate_CountryCode(self.CtryOfBirth)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateAndPlaceOfBirth)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateAndPlaceOfBirth.subclass:
            return DateAndPlaceOfBirth.subclass(*args_, **kwargs_)
        else:
            return DateAndPlaceOfBirth(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BirthDt(self): return self.BirthDt
    def set_BirthDt(self, BirthDt): self.BirthDt = BirthDt
    def get_PrvcOfBirth(self): return self.PrvcOfBirth
    def set_PrvcOfBirth(self, PrvcOfBirth): self.PrvcOfBirth = PrvcOfBirth
    def get_CityOfBirth(self): return self.CityOfBirth
    def set_CityOfBirth(self, CityOfBirth): self.CityOfBirth = CityOfBirth
    def get_CtryOfBirth(self): return self.CtryOfBirth
    def set_CtryOfBirth(self, CtryOfBirth): self.CtryOfBirth = CtryOfBirth
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.BirthDt is not None or
            self.PrvcOfBirth is not None or
            self.CityOfBirth is not None or
            self.CtryOfBirth is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateAndPlaceOfBirth', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateAndPlaceOfBirth')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateAndPlaceOfBirth')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateAndPlaceOfBirth', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateAndPlaceOfBirth'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateAndPlaceOfBirth', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BirthDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBirthDt>%s</%sBirthDt>%s' % (namespace_, self.gds_format_date(self.BirthDt, input_name='BirthDt'), namespace_, eol_))
        if self.PrvcOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrvcOfBirth>%s</%sPrvcOfBirth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrvcOfBirth), input_name='PrvcOfBirth')), namespace_, eol_))
        if self.CityOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCityOfBirth>%s</%sCityOfBirth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CityOfBirth), input_name='CityOfBirth')), namespace_, eol_))
        if self.CtryOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtryOfBirth>%s</%sCtryOfBirth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CtryOfBirth), input_name='CtryOfBirth')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BirthDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.BirthDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.BirthDt)
        elif nodeName_ == 'PrvcOfBirth':
            PrvcOfBirth_ = child_.text
            PrvcOfBirth_ = self.gds_validate_string(PrvcOfBirth_, node, 'PrvcOfBirth')
            self.PrvcOfBirth = PrvcOfBirth_
            # validate type Max35Text
            self.validate_Max35Text(self.PrvcOfBirth)
        elif nodeName_ == 'CityOfBirth':
            CityOfBirth_ = child_.text
            CityOfBirth_ = self.gds_validate_string(CityOfBirth_, node, 'CityOfBirth')
            self.CityOfBirth = CityOfBirth_
            # validate type Max35Text
            self.validate_Max35Text(self.CityOfBirth)
        elif nodeName_ == 'CtryOfBirth':
            CtryOfBirth_ = child_.text
            CtryOfBirth_ = self.gds_validate_string(CtryOfBirth_, node, 'CtryOfBirth')
            self.CtryOfBirth = CtryOfBirth_
            # validate type CountryCode
            self.validate_CountryCode(self.CtryOfBirth)
# end class DateAndPlaceOfBirth


class DatePeriodDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FrDt=None, ToDt=None):
        self.original_tagname_ = None
        if isinstance(FrDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FrDt, '%Y-%m-%d').date()
        else:
            initvalue_ = FrDt
        self.FrDt = initvalue_
        if isinstance(ToDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ToDt, '%Y-%m-%d').date()
        else:
            initvalue_ = ToDt
        self.ToDt = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatePeriodDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatePeriodDetails.subclass:
            return DatePeriodDetails.subclass(*args_, **kwargs_)
        else:
            return DatePeriodDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FrDt(self): return self.FrDt
    def set_FrDt(self, FrDt): self.FrDt = FrDt
    def get_ToDt(self): return self.ToDt
    def set_ToDt(self, ToDt): self.ToDt = ToDt
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.FrDt is not None or
            self.ToDt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DatePeriodDetails', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatePeriodDetails')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatePeriodDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DatePeriodDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatePeriodDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatePeriodDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FrDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFrDt>%s</%sFrDt>%s' % (namespace_, self.gds_format_date(self.FrDt, input_name='FrDt'), namespace_, eol_))
        if self.ToDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sToDt>%s</%sToDt>%s' % (namespace_, self.gds_format_date(self.ToDt, input_name='ToDt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FrDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FrDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.FrDt)
        elif nodeName_ == 'ToDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ToDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.ToDt)
# end class DatePeriodDetails


class Document(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CstmrCdtTrfInitn=None):
        self.original_tagname_ = None
        self.CstmrCdtTrfInitn = CstmrCdtTrfInitn
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Document)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Document.subclass:
            return Document.subclass(*args_, **kwargs_)
        else:
            return Document(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CstmrCdtTrfInitn(self): return self.CstmrCdtTrfInitn
    def set_CstmrCdtTrfInitn(self, CstmrCdtTrfInitn): self.CstmrCdtTrfInitn = CstmrCdtTrfInitn
    def hasContent_(self):
        if (
            self.CstmrCdtTrfInitn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Document', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Document')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Document')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Document', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Document'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Document', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CstmrCdtTrfInitn is not None:
            self.CstmrCdtTrfInitn.export(outfile, level, namespace_, name_='CstmrCdtTrfInitn', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CstmrCdtTrfInitn':
            obj_ = CustomerCreditTransferInitiationV03.factory()
            obj_.build(child_)
            self.CstmrCdtTrfInitn = obj_
            obj_.original_tagname_ = 'CstmrCdtTrfInitn'
# end class Document


class DocumentAdjustment1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Amt=None, CdtDbtInd=None, Rsn=None, AddtlInf=None):
        self.original_tagname_ = None
        self.Amt = Amt
        self.CdtDbtInd = CdtDbtInd
        self.validate_CreditDebitCode(self.CdtDbtInd)
        self.Rsn = Rsn
        self.validate_Max4Text(self.Rsn)
        self.AddtlInf = AddtlInf
        self.validate_Max140Text(self.AddtlInf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentAdjustment1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentAdjustment1.subclass:
            return DocumentAdjustment1.subclass(*args_, **kwargs_)
        else:
            return DocumentAdjustment1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_CdtDbtInd(self): return self.CdtDbtInd
    def set_CdtDbtInd(self, CdtDbtInd): self.CdtDbtInd = CdtDbtInd
    def get_Rsn(self): return self.Rsn
    def set_Rsn(self, Rsn): self.Rsn = Rsn
    def get_AddtlInf(self): return self.AddtlInf
    def set_AddtlInf(self, AddtlInf): self.AddtlInf = AddtlInf
    def validate_CreditDebitCode(self, value):
        # Validate type CreditDebitCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CRDT', 'DBIT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CreditDebitCode' % {"value" : value.encode("utf-8")} )
    def validate_Max4Text(self, value):
        # Validate type Max4Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max4Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max4Text' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Amt is not None or
            self.CdtDbtInd is not None or
            self.Rsn is not None or
            self.AddtlInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocumentAdjustment1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentAdjustment1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentAdjustment1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocumentAdjustment1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentAdjustment1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentAdjustment1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        if self.CdtDbtInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCdtDbtInd>%s</%sCdtDbtInd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CdtDbtInd), input_name='CdtDbtInd')), namespace_, eol_))
        if self.Rsn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRsn>%s</%sRsn>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Rsn), input_name='Rsn')), namespace_, eol_))
        if self.AddtlInf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddtlInf>%s</%sAddtlInf>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AddtlInf), input_name='AddtlInf')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'CdtDbtInd':
            CdtDbtInd_ = child_.text
            CdtDbtInd_ = self.gds_validate_string(CdtDbtInd_, node, 'CdtDbtInd')
            self.CdtDbtInd = CdtDbtInd_
            # validate type CreditDebitCode
            self.validate_CreditDebitCode(self.CdtDbtInd)
        elif nodeName_ == 'Rsn':
            Rsn_ = child_.text
            Rsn_ = self.gds_validate_string(Rsn_, node, 'Rsn')
            self.Rsn = Rsn_
            # validate type Max4Text
            self.validate_Max4Text(self.Rsn)
        elif nodeName_ == 'AddtlInf':
            AddtlInf_ = child_.text
            AddtlInf_ = self.gds_validate_string(AddtlInf_, node, 'AddtlInf')
            self.AddtlInf = AddtlInf_
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlInf)
# end class DocumentAdjustment1


class EquivalentAmount2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Amt=None, CcyOfTrf=None):
        self.original_tagname_ = None
        self.Amt = Amt
        self.CcyOfTrf = CcyOfTrf
        self.validate_ActiveOrHistoricCurrencyCode(self.CcyOfTrf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EquivalentAmount2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EquivalentAmount2.subclass:
            return EquivalentAmount2.subclass(*args_, **kwargs_)
        else:
            return EquivalentAmount2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_CcyOfTrf(self): return self.CcyOfTrf
    def set_CcyOfTrf(self, CcyOfTrf): self.CcyOfTrf = CcyOfTrf
    def validate_ActiveOrHistoricCurrencyCode(self, value):
        # Validate type ActiveOrHistoricCurrencyCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ActiveOrHistoricCurrencyCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ActiveOrHistoricCurrencyCode_patterns_, ))
    validate_ActiveOrHistoricCurrencyCode_patterns_ = [['^[A-Z]{3,3}$']]
    def hasContent_(self):
        if (
            self.Amt is not None or
            self.CcyOfTrf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EquivalentAmount2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EquivalentAmount2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EquivalentAmount2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EquivalentAmount2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EquivalentAmount2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EquivalentAmount2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        if self.CcyOfTrf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCcyOfTrf>%s</%sCcyOfTrf>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CcyOfTrf), input_name='CcyOfTrf')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'CcyOfTrf':
            CcyOfTrf_ = child_.text
            CcyOfTrf_ = self.gds_validate_string(CcyOfTrf_, node, 'CcyOfTrf')
            self.CcyOfTrf = CcyOfTrf_
            # validate type ActiveOrHistoricCurrencyCode
            self.validate_ActiveOrHistoricCurrencyCode(self.CcyOfTrf)
# end class EquivalentAmount2


class ExchangeRateInformation1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, XchgRate=None, RateTp=None, CtrctId=None):
        self.original_tagname_ = None
        self.XchgRate = XchgRate
        self.validate_BaseOneRate(self.XchgRate)
        self.RateTp = RateTp
        self.validate_ExchangeRateType1Code(self.RateTp)
        self.CtrctId = CtrctId
        self.validate_Max35Text(self.CtrctId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeRateInformation1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeRateInformation1.subclass:
            return ExchangeRateInformation1.subclass(*args_, **kwargs_)
        else:
            return ExchangeRateInformation1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XchgRate(self): return self.XchgRate
    def set_XchgRate(self, XchgRate): self.XchgRate = XchgRate
    def get_RateTp(self): return self.RateTp
    def set_RateTp(self, RateTp): self.RateTp = RateTp
    def get_CtrctId(self): return self.CtrctId
    def set_CtrctId(self, CtrctId): self.CtrctId = CtrctId
    def validate_BaseOneRate(self, value):
        # Validate type BaseOneRate, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseOneRate' % {"value" : value} )
    def validate_ExchangeRateType1Code(self, value):
        # Validate type ExchangeRateType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SPOT', 'SALE', 'AGRD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExchangeRateType1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.XchgRate is not None or
            self.RateTp is not None or
            self.CtrctId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeRateInformation1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExchangeRateInformation1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeRateInformation1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeRateInformation1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeRateInformation1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeRateInformation1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.XchgRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXchgRate>%s</%sXchgRate>%s' % (namespace_, self.gds_format_float(self.XchgRate, input_name='XchgRate'), namespace_, eol_))
        if self.RateTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRateTp>%s</%sRateTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RateTp), input_name='RateTp')), namespace_, eol_))
        if self.CtrctId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrctId>%s</%sCtrctId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CtrctId), input_name='CtrctId')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XchgRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'XchgRate')
            self.XchgRate = fval_
            # validate type BaseOneRate
            self.validate_BaseOneRate(self.XchgRate)
        elif nodeName_ == 'RateTp':
            RateTp_ = child_.text
            RateTp_ = self.gds_validate_string(RateTp_, node, 'RateTp')
            self.RateTp = RateTp_
            # validate type ExchangeRateType1Code
            self.validate_ExchangeRateType1Code(self.RateTp)
        elif nodeName_ == 'CtrctId':
            CtrctId_ = child_.text
            CtrctId_ = self.gds_validate_string(CtrctId_, node, 'CtrctId')
            self.CtrctId = CtrctId_
            # validate type Max35Text
            self.validate_Max35Text(self.CtrctId)
# end class ExchangeRateInformation1


class FinancialIdentificationSchemeName1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalFinancialInstitutionIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialIdentificationSchemeName1Choice.subclass:
            return FinancialIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return FinancialIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalFinancialInstitutionIdentification1Code(self, value):
        # Validate type ExternalFinancialInstitutionIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalFinancialInstitutionIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalFinancialInstitutionIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinancialIdentificationSchemeName1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinancialIdentificationSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialIdentificationSchemeName1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinancialIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinancialIdentificationSchemeName1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinancialIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalFinancialInstitutionIdentification1Code
            self.validate_ExternalFinancialInstitutionIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class FinancialIdentificationSchemeName1Choice


class FinancialInstitutionIdentification7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BIC=None, ClrSysMmbId=None, Nm=None, PstlAdr=None, Othr=None):
        self.original_tagname_ = None
        self.BIC = BIC
        self.validate_BICIdentifier(self.BIC)
        self.ClrSysMmbId = ClrSysMmbId
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PstlAdr = PstlAdr
        self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialInstitutionIdentification7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialInstitutionIdentification7.subclass:
            return FinancialInstitutionIdentification7.subclass(*args_, **kwargs_)
        else:
            return FinancialInstitutionIdentification7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BIC(self): return self.BIC
    def set_BIC(self, BIC): self.BIC = BIC
    def get_ClrSysMmbId(self): return self.ClrSysMmbId
    def set_ClrSysMmbId(self, ClrSysMmbId): self.ClrSysMmbId = ClrSysMmbId
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def validate_BICIdentifier(self, value):
        # Validate type BICIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_BICIdentifier_patterns_, ))
    validate_BICIdentifier_patterns_ = [['^[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}$']]
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.BIC is not None or
            self.ClrSysMmbId is not None or
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Othr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinancialInstitutionIdentification7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialInstitutionIdentification7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinancialInstitutionIdentification7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinancialInstitutionIdentification7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinancialInstitutionIdentification7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIC>%s</%sBIC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BIC), input_name='BIC')), namespace_, eol_))
        if self.ClrSysMmbId is not None:
            self.ClrSysMmbId.export(outfile, level, namespace_, name_='ClrSysMmbId', pretty_print=pretty_print)
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
        if self.Othr is not None:
            self.Othr.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BIC':
            BIC_ = child_.text
            BIC_ = self.gds_validate_string(BIC_, node, 'BIC')
            self.BIC = BIC_
            # validate type BICIdentifier
            self.validate_BICIdentifier(self.BIC)
        elif nodeName_ == 'ClrSysMmbId':
            obj_ = ClearingSystemMemberIdentification2.factory()
            obj_.build(child_)
            self.ClrSysMmbId = obj_
            obj_.original_tagname_ = 'ClrSysMmbId'
        elif nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Othr':
            obj_ = GenericFinancialIdentification1.factory()
            obj_.build(child_)
            self.Othr = obj_
            obj_.original_tagname_ = 'Othr'
# end class FinancialInstitutionIdentification7


class GenericAccountIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max34Text(self.Id)
        self.SchmeNm = SchmeNm
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericAccountIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericAccountIdentification1.subclass:
            return GenericAccountIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericAccountIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SchmeNm(self): return self.SchmeNm
    def set_SchmeNm(self, SchmeNm): self.SchmeNm = SchmeNm
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max34Text(self, value):
        # Validate type Max34Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 34:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max34Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max34Text' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericAccountIdentification1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericAccountIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericAccountIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericAccountIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericAccountIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericAccountIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespace_, eol_))
        if self.SchmeNm is not None:
            self.SchmeNm.export(outfile, level, namespace_, name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
            # validate type Max34Text
            self.validate_Max34Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = AccountSchemeName1Choice.factory()
            obj_.build(child_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            Issr_ = child_.text
            Issr_ = self.gds_validate_string(Issr_, node, 'Issr')
            self.Issr = Issr_
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericAccountIdentification1


class GenericFinancialIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.SchmeNm = SchmeNm
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericFinancialIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericFinancialIdentification1.subclass:
            return GenericFinancialIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericFinancialIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SchmeNm(self): return self.SchmeNm
    def set_SchmeNm(self, SchmeNm): self.SchmeNm = SchmeNm
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericFinancialIdentification1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericFinancialIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericFinancialIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericFinancialIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericFinancialIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericFinancialIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespace_, eol_))
        if self.SchmeNm is not None:
            self.SchmeNm.export(outfile, level, namespace_, name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = FinancialIdentificationSchemeName1Choice.factory()
            obj_.build(child_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            Issr_ = child_.text
            Issr_ = self.gds_validate_string(Issr_, node, 'Issr')
            self.Issr = Issr_
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericFinancialIdentification1


class GenericOrganisationIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.SchmeNm = SchmeNm
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericOrganisationIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericOrganisationIdentification1.subclass:
            return GenericOrganisationIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericOrganisationIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SchmeNm(self): return self.SchmeNm
    def set_SchmeNm(self, SchmeNm): self.SchmeNm = SchmeNm
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericOrganisationIdentification1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericOrganisationIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericOrganisationIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericOrganisationIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericOrganisationIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericOrganisationIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespace_, eol_))
        if self.SchmeNm is not None:
            self.SchmeNm.export(outfile, level, namespace_, name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = OrganisationIdentificationSchemeName1Choice.factory()
            obj_.build(child_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            Issr_ = child_.text
            Issr_ = self.gds_validate_string(Issr_, node, 'Issr')
            self.Issr = Issr_
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericOrganisationIdentification1


class GenericPersonIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SchmeNm=None, Issr=None):
        self.original_tagname_ = None
        self.Id = Id
        self.validate_Max35Text(self.Id)
        self.SchmeNm = SchmeNm
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericPersonIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericPersonIdentification1.subclass:
            return GenericPersonIdentification1.subclass(*args_, **kwargs_)
        else:
            return GenericPersonIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SchmeNm(self): return self.SchmeNm
    def set_SchmeNm(self, SchmeNm): self.SchmeNm = SchmeNm
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SchmeNm is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericPersonIdentification1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericPersonIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericPersonIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericPersonIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericPersonIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericPersonIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), namespace_, eol_))
        if self.SchmeNm is not None:
            self.SchmeNm.export(outfile, level, namespace_, name_='SchmeNm', pretty_print=pretty_print)
        if self.Issr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
            # validate type Max35Text
            self.validate_Max35Text(self.Id)
        elif nodeName_ == 'SchmeNm':
            obj_ = PersonIdentificationSchemeName1Choice.factory()
            obj_.build(child_)
            self.SchmeNm = obj_
            obj_.original_tagname_ = 'SchmeNm'
        elif nodeName_ == 'Issr':
            Issr_ = child_.text
            Issr_ = self.gds_validate_string(Issr_, node, 'Issr')
            self.Issr = Issr_
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class GenericPersonIdentification1


class GroupHeader32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MsgId=None, CreDtTm=None, Authstn=None, NbOfTxs=None, CtrlSum=None, InitgPty=None, FwdgAgt=None):
        self.original_tagname_ = None
        self.MsgId = MsgId
        self.validate_Max35Text(self.MsgId)
        if isinstance(CreDtTm, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CreDtTm, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CreDtTm
        self.CreDtTm = initvalue_
        if Authstn is None:
            self.Authstn = []
        else:
            self.Authstn = Authstn
        self.NbOfTxs = NbOfTxs
        self.validate_Max15NumericText(self.NbOfTxs)
        self.CtrlSum = CtrlSum
        self.validate_DecimalNumber(self.CtrlSum)
        self.InitgPty = InitgPty
        self.FwdgAgt = FwdgAgt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroupHeader32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroupHeader32.subclass:
            return GroupHeader32.subclass(*args_, **kwargs_)
        else:
            return GroupHeader32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MsgId(self): return self.MsgId
    def set_MsgId(self, MsgId): self.MsgId = MsgId
    def get_CreDtTm(self): return self.CreDtTm
    def set_CreDtTm(self, CreDtTm): self.CreDtTm = CreDtTm
    def get_Authstn(self): return self.Authstn
    def set_Authstn(self, Authstn): self.Authstn = Authstn
    def add_Authstn(self, value): self.Authstn.append(value)
    def insert_Authstn_at(self, index, value): self.Authstn.insert(index, value)
    def replace_Authstn_at(self, index, value): self.Authstn[index] = value
    def get_NbOfTxs(self): return self.NbOfTxs
    def set_NbOfTxs(self, NbOfTxs): self.NbOfTxs = NbOfTxs
    def get_CtrlSum(self): return self.CtrlSum
    def set_CtrlSum(self, CtrlSum): self.CtrlSum = CtrlSum
    def get_InitgPty(self): return self.InitgPty
    def set_InitgPty(self, InitgPty): self.InitgPty = InitgPty
    def get_FwdgAgt(self): return self.FwdgAgt
    def set_FwdgAgt(self, FwdgAgt): self.FwdgAgt = FwdgAgt
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_ISODateTime(self, value):
        # Validate type ISODateTime, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Max15NumericText(self, value):
        # Validate type Max15NumericText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Max15NumericText_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max15NumericText_patterns_, ))
    validate_Max15NumericText_patterns_ = [['^[0-9]{1,15}$']]
    def validate_DecimalNumber(self, value):
        # Validate type DecimalNumber, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DecimalNumber' % {"value" : value} )
    def hasContent_(self):
        if (
            self.MsgId is not None or
            self.CreDtTm is not None or
            self.Authstn or
            self.NbOfTxs is not None or
            self.CtrlSum is not None or
            self.InitgPty is not None or
            self.FwdgAgt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GroupHeader32', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GroupHeader32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupHeader32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GroupHeader32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupHeader32'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupHeader32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MsgId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMsgId>%s</%sMsgId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MsgId), input_name='MsgId')), namespace_, eol_))
        if self.CreDtTm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreDtTm>%s</%sCreDtTm>%s' % (namespace_, self.gds_format_datetime(self.CreDtTm, input_name='CreDtTm'), namespace_, eol_))
        for Authstn_ in self.Authstn:
            Authstn_.export(outfile, level, namespace_, name_='Authstn', pretty_print=pretty_print)
        if self.NbOfTxs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNbOfTxs>%s</%sNbOfTxs>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NbOfTxs), input_name='NbOfTxs')), namespace_, eol_))
        if self.CtrlSum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrlSum>%s</%sCtrlSum>%s' % (namespace_, self.gds_format_float(self.CtrlSum, input_name='CtrlSum'), namespace_, eol_))
        if self.InitgPty is not None:
            self.InitgPty.export(outfile, level, namespace_, name_='InitgPty', pretty_print=pretty_print)
        if self.FwdgAgt is not None:
            self.FwdgAgt.export(outfile, level, namespace_, name_='FwdgAgt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MsgId':
            MsgId_ = child_.text
            MsgId_ = self.gds_validate_string(MsgId_, node, 'MsgId')
            self.MsgId = MsgId_
            # validate type Max35Text
            self.validate_Max35Text(self.MsgId)
        elif nodeName_ == 'CreDtTm':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.CreDtTm = dval_
            # validate type ISODateTime
            self.validate_ISODateTime(self.CreDtTm)
        elif nodeName_ == 'Authstn':
            obj_ = Authorisation1Choice.factory()
            obj_.build(child_)
            self.Authstn.append(obj_)
            obj_.original_tagname_ = 'Authstn'
        elif nodeName_ == 'NbOfTxs':
            NbOfTxs_ = child_.text
            NbOfTxs_ = self.gds_validate_string(NbOfTxs_, node, 'NbOfTxs')
            self.NbOfTxs = NbOfTxs_
            # validate type Max15NumericText
            self.validate_Max15NumericText(self.NbOfTxs)
        elif nodeName_ == 'CtrlSum':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CtrlSum')
            self.CtrlSum = fval_
            # validate type DecimalNumber
            self.validate_DecimalNumber(self.CtrlSum)
        elif nodeName_ == 'InitgPty':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.InitgPty = obj_
            obj_.original_tagname_ = 'InitgPty'
        elif nodeName_ == 'FwdgAgt':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.FwdgAgt = obj_
            obj_.original_tagname_ = 'FwdgAgt'
# end class GroupHeader32


class InstructionForCreditorAgent1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, InstrInf=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_Instruction3Code(self.Cd)
        self.InstrInf = InstrInf
        self.validate_Max140Text(self.InstrInf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstructionForCreditorAgent1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstructionForCreditorAgent1.subclass:
            return InstructionForCreditorAgent1.subclass(*args_, **kwargs_)
        else:
            return InstructionForCreditorAgent1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_InstrInf(self): return self.InstrInf
    def set_InstrInf(self, InstrInf): self.InstrInf = InstrInf
    def validate_Instruction3Code(self, value):
        # Validate type Instruction3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CHQB', 'HOLD', 'PHOB', 'TELB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Instruction3Code' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.InstrInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstructionForCreditorAgent1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstructionForCreditorAgent1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstructionForCreditorAgent1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstructionForCreditorAgent1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstructionForCreditorAgent1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstructionForCreditorAgent1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.InstrInf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrInf>%s</%sInstrInf>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrInf), input_name='InstrInf')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type Instruction3Code
            self.validate_Instruction3Code(self.Cd)
        elif nodeName_ == 'InstrInf':
            InstrInf_ = child_.text
            InstrInf_ = self.gds_validate_string(InstrInf_, node, 'InstrInf')
            self.InstrInf = InstrInf_
            # validate type Max140Text
            self.validate_Max140Text(self.InstrInf)
# end class InstructionForCreditorAgent1


class LocalInstrument2Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalLocalInstrument1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalInstrument2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalInstrument2Choice.subclass:
            return LocalInstrument2Choice.subclass(*args_, **kwargs_)
        else:
            return LocalInstrument2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalLocalInstrument1Code(self, value):
        # Validate type ExternalLocalInstrument1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalLocalInstrument1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalLocalInstrument1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LocalInstrument2Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalInstrument2Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalInstrument2Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LocalInstrument2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalInstrument2Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocalInstrument2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalLocalInstrument1Code
            self.validate_ExternalLocalInstrument1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class LocalInstrument2Choice


class NameAndAddress10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, Adr=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Adr = Adr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameAndAddress10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameAndAddress10.subclass:
            return NameAndAddress10.subclass(*args_, **kwargs_)
        else:
            return NameAndAddress10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_Adr(self): return self.Adr
    def set_Adr(self, Adr): self.Adr = Adr
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.Adr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NameAndAddress10', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameAndAddress10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameAndAddress10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NameAndAddress10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameAndAddress10'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NameAndAddress10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
        if self.Adr is not None:
            self.Adr.export(outfile, level, namespace_, name_='Adr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'Adr':
            obj_ = PostalAddress6.factory()
            obj_.build(child_)
            self.Adr = obj_
            obj_.original_tagname_ = 'Adr'
# end class NameAndAddress10


class OrganisationIdentification4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BICOrBEI=None, Othr=None):
        self.original_tagname_ = None
        self.BICOrBEI = BICOrBEI
        self.validate_AnyBICIdentifier(self.BICOrBEI)
        if Othr is None:
            self.Othr = []
        else:
            self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationIdentification4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationIdentification4.subclass:
            return OrganisationIdentification4.subclass(*args_, **kwargs_)
        else:
            return OrganisationIdentification4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BICOrBEI(self): return self.BICOrBEI
    def set_BICOrBEI(self, BICOrBEI): self.BICOrBEI = BICOrBEI
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def add_Othr(self, value): self.Othr.append(value)
    def insert_Othr_at(self, index, value): self.Othr.insert(index, value)
    def replace_Othr_at(self, index, value): self.Othr[index] = value
    def validate_AnyBICIdentifier(self, value):
        # Validate type AnyBICIdentifier, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AnyBICIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AnyBICIdentifier_patterns_, ))
    validate_AnyBICIdentifier_patterns_ = [['^[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}$']]
    def hasContent_(self):
        if (
            self.BICOrBEI is not None or
            self.Othr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganisationIdentification4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationIdentification4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationIdentification4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganisationIdentification4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationIdentification4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationIdentification4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BICOrBEI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBICOrBEI>%s</%sBICOrBEI>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BICOrBEI), input_name='BICOrBEI')), namespace_, eol_))
        for Othr_ in self.Othr:
            Othr_.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BICOrBEI':
            BICOrBEI_ = child_.text
            BICOrBEI_ = self.gds_validate_string(BICOrBEI_, node, 'BICOrBEI')
            self.BICOrBEI = BICOrBEI_
            # validate type AnyBICIdentifier
            self.validate_AnyBICIdentifier(self.BICOrBEI)
        elif nodeName_ == 'Othr':
            obj_ = GenericOrganisationIdentification1.factory()
            obj_.build(child_)
            self.Othr.append(obj_)
            obj_.original_tagname_ = 'Othr'
# end class OrganisationIdentification4


class OrganisationIdentificationSchemeName1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalOrganisationIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationIdentificationSchemeName1Choice.subclass:
            return OrganisationIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return OrganisationIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalOrganisationIdentification1Code(self, value):
        # Validate type ExternalOrganisationIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalOrganisationIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalOrganisationIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganisationIdentificationSchemeName1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationIdentificationSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationIdentificationSchemeName1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganisationIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationIdentificationSchemeName1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalOrganisationIdentification1Code
            self.validate_ExternalOrganisationIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class OrganisationIdentificationSchemeName1Choice


class Party6Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OrgId=None, PrvtId=None):
        self.original_tagname_ = None
        self.OrgId = OrgId
        self.PrvtId = PrvtId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party6Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party6Choice.subclass:
            return Party6Choice.subclass(*args_, **kwargs_)
        else:
            return Party6Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrgId(self): return self.OrgId
    def set_OrgId(self, OrgId): self.OrgId = OrgId
    def get_PrvtId(self): return self.PrvtId
    def set_PrvtId(self, PrvtId): self.PrvtId = PrvtId
    def hasContent_(self):
        if (
            self.OrgId is not None or
            self.PrvtId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Party6Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Party6Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Party6Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Party6Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Party6Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Party6Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrgId is not None:
            self.OrgId.export(outfile, level, namespace_, name_='OrgId', pretty_print=pretty_print)
        if self.PrvtId is not None:
            self.PrvtId.export(outfile, level, namespace_, name_='PrvtId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrgId':
            obj_ = OrganisationIdentification4.factory()
            obj_.build(child_)
            self.OrgId = obj_
            obj_.original_tagname_ = 'OrgId'
        elif nodeName_ == 'PrvtId':
            obj_ = PersonIdentification5.factory()
            obj_.build(child_)
            self.PrvtId = obj_
            obj_.original_tagname_ = 'PrvtId'
# end class Party6Choice


class PartyIdentification32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, PstlAdr=None, Id=None, CtryOfRes=None, CtctDtls=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.PstlAdr = PstlAdr
        self.Id = Id
        self.CtryOfRes = CtryOfRes
        self.validate_CountryCode(self.CtryOfRes)
        self.CtctDtls = CtctDtls
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyIdentification32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyIdentification32.subclass:
            return PartyIdentification32.subclass(*args_, **kwargs_)
        else:
            return PartyIdentification32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_PstlAdr(self): return self.PstlAdr
    def set_PstlAdr(self, PstlAdr): self.PstlAdr = PstlAdr
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_CtryOfRes(self): return self.CtryOfRes
    def set_CtryOfRes(self, CtryOfRes): self.CtryOfRes = CtryOfRes
    def get_CtctDtls(self): return self.CtctDtls
    def set_CtctDtls(self, CtctDtls): self.CtctDtls = CtctDtls
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.PstlAdr is not None or
            self.Id is not None or
            self.CtryOfRes is not None or
            self.CtctDtls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyIdentification32', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartyIdentification32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyIdentification32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyIdentification32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyIdentification32'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyIdentification32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
        if self.PstlAdr is not None:
            self.PstlAdr.export(outfile, level, namespace_, name_='PstlAdr', pretty_print=pretty_print)
        if self.Id is not None:
            self.Id.export(outfile, level, namespace_, name_='Id', pretty_print=pretty_print)
        if self.CtryOfRes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtryOfRes>%s</%sCtryOfRes>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CtryOfRes), input_name='CtryOfRes')), namespace_, eol_))
        if self.CtctDtls is not None:
            self.CtctDtls.export(outfile, level, namespace_, name_='CtctDtls', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'PstlAdr':
            obj_ = PostalAddress6.factory()
            obj_.build(child_)
            self.PstlAdr = obj_
            obj_.original_tagname_ = 'PstlAdr'
        elif nodeName_ == 'Id':
            obj_ = Party6Choice.factory()
            obj_.build(child_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'CtryOfRes':
            CtryOfRes_ = child_.text
            CtryOfRes_ = self.gds_validate_string(CtryOfRes_, node, 'CtryOfRes')
            self.CtryOfRes = CtryOfRes_
            # validate type CountryCode
            self.validate_CountryCode(self.CtryOfRes)
        elif nodeName_ == 'CtctDtls':
            obj_ = ContactDetails2.factory()
            obj_.build(child_)
            self.CtctDtls = obj_
            obj_.original_tagname_ = 'CtctDtls'
# end class PartyIdentification32


class PaymentIdentification1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InstrId=None, EndToEndId=None):
        self.original_tagname_ = None
        self.InstrId = InstrId
        self.validate_Max35Text(self.InstrId)
        self.EndToEndId = EndToEndId
        self.validate_Max35Text(self.EndToEndId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentIdentification1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentIdentification1.subclass:
            return PaymentIdentification1.subclass(*args_, **kwargs_)
        else:
            return PaymentIdentification1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InstrId(self): return self.InstrId
    def set_InstrId(self, InstrId): self.InstrId = InstrId
    def get_EndToEndId(self): return self.EndToEndId
    def set_EndToEndId(self, EndToEndId): self.EndToEndId = EndToEndId
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InstrId is not None or
            self.EndToEndId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentIdentification1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentIdentification1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentIdentification1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentIdentification1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentIdentification1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentIdentification1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstrId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrId>%s</%sInstrId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrId), input_name='InstrId')), namespace_, eol_))
        if self.EndToEndId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndToEndId>%s</%sEndToEndId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EndToEndId), input_name='EndToEndId')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstrId':
            InstrId_ = child_.text
            InstrId_ = self.gds_validate_string(InstrId_, node, 'InstrId')
            self.InstrId = InstrId_
            # validate type Max35Text
            self.validate_Max35Text(self.InstrId)
        elif nodeName_ == 'EndToEndId':
            EndToEndId_ = child_.text
            EndToEndId_ = self.gds_validate_string(EndToEndId_, node, 'EndToEndId')
            self.EndToEndId = EndToEndId_
            # validate type Max35Text
            self.validate_Max35Text(self.EndToEndId)
# end class PaymentIdentification1


class PaymentInstructionInformation3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PmtInfId=None, PmtMtd=None, BtchBookg=None, NbOfTxs=None, CtrlSum=None, PmtTpInf=None, ReqdExctnDt=None, PoolgAdjstmntDt=None, Dbtr=None, DbtrAcct=None, DbtrAgt=None, DbtrAgtAcct=None, UltmtDbtr=None, ChrgBr=None, ChrgsAcct=None, ChrgsAcctAgt=None, CdtTrfTxInf=None):
        self.original_tagname_ = None
        self.PmtInfId = PmtInfId
        self.validate_Max35Text(self.PmtInfId)
        self.PmtMtd = PmtMtd
        self.validate_PaymentMethod3Code(self.PmtMtd)
        self.BtchBookg = BtchBookg
        self.validate_BatchBookingIndicator(self.BtchBookg)
        self.NbOfTxs = NbOfTxs
        self.validate_Max15NumericText(self.NbOfTxs)
        self.CtrlSum = CtrlSum
        self.validate_DecimalNumber(self.CtrlSum)
        self.PmtTpInf = PmtTpInf
        if isinstance(ReqdExctnDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ReqdExctnDt, '%Y-%m-%d').date()
        else:
            initvalue_ = ReqdExctnDt
        self.ReqdExctnDt = initvalue_
        if isinstance(PoolgAdjstmntDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PoolgAdjstmntDt, '%Y-%m-%d').date()
        else:
            initvalue_ = PoolgAdjstmntDt
        self.PoolgAdjstmntDt = initvalue_
        self.Dbtr = Dbtr
        self.DbtrAcct = DbtrAcct
        self.DbtrAgt = DbtrAgt
        self.DbtrAgtAcct = DbtrAgtAcct
        self.UltmtDbtr = UltmtDbtr
        self.ChrgBr = ChrgBr
        self.validate_ChargeBearerType1Code(self.ChrgBr)
        self.ChrgsAcct = ChrgsAcct
        self.ChrgsAcctAgt = ChrgsAcctAgt
        if CdtTrfTxInf is None:
            self.CdtTrfTxInf = []
        else:
            self.CdtTrfTxInf = CdtTrfTxInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentInstructionInformation3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentInstructionInformation3.subclass:
            return PaymentInstructionInformation3.subclass(*args_, **kwargs_)
        else:
            return PaymentInstructionInformation3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PmtInfId(self): return self.PmtInfId
    def set_PmtInfId(self, PmtInfId): self.PmtInfId = PmtInfId
    def get_PmtMtd(self): return self.PmtMtd
    def set_PmtMtd(self, PmtMtd): self.PmtMtd = PmtMtd
    def get_BtchBookg(self): return self.BtchBookg
    def set_BtchBookg(self, BtchBookg): self.BtchBookg = BtchBookg
    def get_NbOfTxs(self): return self.NbOfTxs
    def set_NbOfTxs(self, NbOfTxs): self.NbOfTxs = NbOfTxs
    def get_CtrlSum(self): return self.CtrlSum
    def set_CtrlSum(self, CtrlSum): self.CtrlSum = CtrlSum
    def get_PmtTpInf(self): return self.PmtTpInf
    def set_PmtTpInf(self, PmtTpInf): self.PmtTpInf = PmtTpInf
    def get_ReqdExctnDt(self): return self.ReqdExctnDt
    def set_ReqdExctnDt(self, ReqdExctnDt): self.ReqdExctnDt = ReqdExctnDt
    def get_PoolgAdjstmntDt(self): return self.PoolgAdjstmntDt
    def set_PoolgAdjstmntDt(self, PoolgAdjstmntDt): self.PoolgAdjstmntDt = PoolgAdjstmntDt
    def get_Dbtr(self): return self.Dbtr
    def set_Dbtr(self, Dbtr): self.Dbtr = Dbtr
    def get_DbtrAcct(self): return self.DbtrAcct
    def set_DbtrAcct(self, DbtrAcct): self.DbtrAcct = DbtrAcct
    def get_DbtrAgt(self): return self.DbtrAgt
    def set_DbtrAgt(self, DbtrAgt): self.DbtrAgt = DbtrAgt
    def get_DbtrAgtAcct(self): return self.DbtrAgtAcct
    def set_DbtrAgtAcct(self, DbtrAgtAcct): self.DbtrAgtAcct = DbtrAgtAcct
    def get_UltmtDbtr(self): return self.UltmtDbtr
    def set_UltmtDbtr(self, UltmtDbtr): self.UltmtDbtr = UltmtDbtr
    def get_ChrgBr(self): return self.ChrgBr
    def set_ChrgBr(self, ChrgBr): self.ChrgBr = ChrgBr
    def get_ChrgsAcct(self): return self.ChrgsAcct
    def set_ChrgsAcct(self, ChrgsAcct): self.ChrgsAcct = ChrgsAcct
    def get_ChrgsAcctAgt(self): return self.ChrgsAcctAgt
    def set_ChrgsAcctAgt(self, ChrgsAcctAgt): self.ChrgsAcctAgt = ChrgsAcctAgt
    def get_CdtTrfTxInf(self): return self.CdtTrfTxInf
    def set_CdtTrfTxInf(self, CdtTrfTxInf): self.CdtTrfTxInf = CdtTrfTxInf
    def add_CdtTrfTxInf(self, value): self.CdtTrfTxInf.append(value)
    def insert_CdtTrfTxInf_at(self, index, value): self.CdtTrfTxInf.insert(index, value)
    def replace_CdtTrfTxInf_at(self, index, value): self.CdtTrfTxInf[index] = value
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_PaymentMethod3Code(self, value):
        # Validate type PaymentMethod3Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CHK', 'TRF', 'TRA']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PaymentMethod3Code' % {"value" : value.encode("utf-8")} )
    def validate_BatchBookingIndicator(self, value):
        # Validate type BatchBookingIndicator, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Max15NumericText(self, value):
        # Validate type Max15NumericText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Max15NumericText_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Max15NumericText_patterns_, ))
    validate_Max15NumericText_patterns_ = [['^[0-9]{1,15}$']]
    def validate_DecimalNumber(self, value):
        # Validate type DecimalNumber, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DecimalNumber' % {"value" : value} )
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ChargeBearerType1Code(self, value):
        # Validate type ChargeBearerType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEBT', 'CRED', 'SHAR', 'SLEV']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChargeBearerType1Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PmtInfId is not None or
            self.PmtMtd is not None or
            self.BtchBookg is not None or
            self.NbOfTxs is not None or
            self.CtrlSum is not None or
            self.PmtTpInf is not None or
            self.ReqdExctnDt is not None or
            self.PoolgAdjstmntDt is not None or
            self.Dbtr is not None or
            self.DbtrAcct is not None or
            self.DbtrAgt is not None or
            self.DbtrAgtAcct is not None or
            self.UltmtDbtr is not None or
            self.ChrgBr is not None or
            self.ChrgsAcct is not None or
            self.ChrgsAcctAgt is not None or
            self.CdtTrfTxInf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentInstructionInformation3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentInstructionInformation3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentInstructionInformation3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentInstructionInformation3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentInstructionInformation3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentInstructionInformation3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PmtInfId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPmtInfId>%s</%sPmtInfId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PmtInfId), input_name='PmtInfId')), namespace_, eol_))
        if self.PmtMtd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPmtMtd>%s</%sPmtMtd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PmtMtd), input_name='PmtMtd')), namespace_, eol_))
        if self.BtchBookg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBtchBookg>%s</%sBtchBookg>%s' % (namespace_, self.gds_format_boolean(self.BtchBookg, input_name='BtchBookg'), namespace_, eol_))
        if self.NbOfTxs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNbOfTxs>%s</%sNbOfTxs>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NbOfTxs), input_name='NbOfTxs')), namespace_, eol_))
        if self.CtrlSum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrlSum>%s</%sCtrlSum>%s' % (namespace_, self.gds_format_float(self.CtrlSum, input_name='CtrlSum'), namespace_, eol_))
        if self.PmtTpInf is not None:
            self.PmtTpInf.export(outfile, level, namespace_, name_='PmtTpInf', pretty_print=pretty_print)
        if self.ReqdExctnDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReqdExctnDt>%s</%sReqdExctnDt>%s' % (namespace_, self.gds_format_date(self.ReqdExctnDt, input_name='ReqdExctnDt'), namespace_, eol_))
        if self.PoolgAdjstmntDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPoolgAdjstmntDt>%s</%sPoolgAdjstmntDt>%s' % (namespace_, self.gds_format_date(self.PoolgAdjstmntDt, input_name='PoolgAdjstmntDt'), namespace_, eol_))
        if self.Dbtr is not None:
            self.Dbtr.export(outfile, level, namespace_, name_='Dbtr', pretty_print=pretty_print)
        if self.DbtrAcct is not None:
            self.DbtrAcct.export(outfile, level, namespace_, name_='DbtrAcct', pretty_print=pretty_print)
        if self.DbtrAgt is not None:
            self.DbtrAgt.export(outfile, level, namespace_, name_='DbtrAgt', pretty_print=pretty_print)
        if self.DbtrAgtAcct is not None:
            self.DbtrAgtAcct.export(outfile, level, namespace_, name_='DbtrAgtAcct', pretty_print=pretty_print)
        if self.UltmtDbtr is not None:
            self.UltmtDbtr.export(outfile, level, namespace_, name_='UltmtDbtr', pretty_print=pretty_print)
        if self.ChrgBr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChrgBr>%s</%sChrgBr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChrgBr), input_name='ChrgBr')), namespace_, eol_))
        if self.ChrgsAcct is not None:
            self.ChrgsAcct.export(outfile, level, namespace_, name_='ChrgsAcct', pretty_print=pretty_print)
        if self.ChrgsAcctAgt is not None:
            self.ChrgsAcctAgt.export(outfile, level, namespace_, name_='ChrgsAcctAgt', pretty_print=pretty_print)
        for CdtTrfTxInf_ in self.CdtTrfTxInf:
            CdtTrfTxInf_.export(outfile, level, namespace_, name_='CdtTrfTxInf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PmtInfId':
            PmtInfId_ = child_.text
            PmtInfId_ = self.gds_validate_string(PmtInfId_, node, 'PmtInfId')
            self.PmtInfId = PmtInfId_
            # validate type Max35Text
            self.validate_Max35Text(self.PmtInfId)
        elif nodeName_ == 'PmtMtd':
            PmtMtd_ = child_.text
            PmtMtd_ = self.gds_validate_string(PmtMtd_, node, 'PmtMtd')
            self.PmtMtd = PmtMtd_
            # validate type PaymentMethod3Code
            self.validate_PaymentMethod3Code(self.PmtMtd)
        elif nodeName_ == 'BtchBookg':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BtchBookg')
            self.BtchBookg = ival_
            # validate type BatchBookingIndicator
            self.validate_BatchBookingIndicator(self.BtchBookg)
        elif nodeName_ == 'NbOfTxs':
            NbOfTxs_ = child_.text
            NbOfTxs_ = self.gds_validate_string(NbOfTxs_, node, 'NbOfTxs')
            self.NbOfTxs = NbOfTxs_
            # validate type Max15NumericText
            self.validate_Max15NumericText(self.NbOfTxs)
        elif nodeName_ == 'CtrlSum':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CtrlSum')
            self.CtrlSum = fval_
            # validate type DecimalNumber
            self.validate_DecimalNumber(self.CtrlSum)
        elif nodeName_ == 'PmtTpInf':
            obj_ = PaymentTypeInformation19.factory()
            obj_.build(child_)
            self.PmtTpInf = obj_
            obj_.original_tagname_ = 'PmtTpInf'
        elif nodeName_ == 'ReqdExctnDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ReqdExctnDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.ReqdExctnDt)
        elif nodeName_ == 'PoolgAdjstmntDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PoolgAdjstmntDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.PoolgAdjstmntDt)
        elif nodeName_ == 'Dbtr':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.Dbtr = obj_
            obj_.original_tagname_ = 'Dbtr'
        elif nodeName_ == 'DbtrAcct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.DbtrAcct = obj_
            obj_.original_tagname_ = 'DbtrAcct'
        elif nodeName_ == 'DbtrAgt':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.DbtrAgt = obj_
            obj_.original_tagname_ = 'DbtrAgt'
        elif nodeName_ == 'DbtrAgtAcct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.DbtrAgtAcct = obj_
            obj_.original_tagname_ = 'DbtrAgtAcct'
        elif nodeName_ == 'UltmtDbtr':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.UltmtDbtr = obj_
            obj_.original_tagname_ = 'UltmtDbtr'
        elif nodeName_ == 'ChrgBr':
            ChrgBr_ = child_.text
            ChrgBr_ = self.gds_validate_string(ChrgBr_, node, 'ChrgBr')
            self.ChrgBr = ChrgBr_
            # validate type ChargeBearerType1Code
            self.validate_ChargeBearerType1Code(self.ChrgBr)
        elif nodeName_ == 'ChrgsAcct':
            obj_ = CashAccount16.factory()
            obj_.build(child_)
            self.ChrgsAcct = obj_
            obj_.original_tagname_ = 'ChrgsAcct'
        elif nodeName_ == 'ChrgsAcctAgt':
            obj_ = BranchAndFinancialInstitutionIdentification4.factory()
            obj_.build(child_)
            self.ChrgsAcctAgt = obj_
            obj_.original_tagname_ = 'ChrgsAcctAgt'
        elif nodeName_ == 'CdtTrfTxInf':
            obj_ = CreditTransferTransactionInformation10.factory()
            obj_.build(child_)
            self.CdtTrfTxInf.append(obj_)
            obj_.original_tagname_ = 'CdtTrfTxInf'
# end class PaymentInstructionInformation3


class PaymentTypeInformation19(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InstrPrty=None, SvcLvl=None, LclInstrm=None, CtgyPurp=None):
        self.original_tagname_ = None
        self.InstrPrty = InstrPrty
        self.validate_Priority2Code(self.InstrPrty)
        self.SvcLvl = SvcLvl
        self.LclInstrm = LclInstrm
        self.CtgyPurp = CtgyPurp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentTypeInformation19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentTypeInformation19.subclass:
            return PaymentTypeInformation19.subclass(*args_, **kwargs_)
        else:
            return PaymentTypeInformation19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InstrPrty(self): return self.InstrPrty
    def set_InstrPrty(self, InstrPrty): self.InstrPrty = InstrPrty
    def get_SvcLvl(self): return self.SvcLvl
    def set_SvcLvl(self, SvcLvl): self.SvcLvl = SvcLvl
    def get_LclInstrm(self): return self.LclInstrm
    def set_LclInstrm(self, LclInstrm): self.LclInstrm = LclInstrm
    def get_CtgyPurp(self): return self.CtgyPurp
    def set_CtgyPurp(self, CtgyPurp): self.CtgyPurp = CtgyPurp
    def validate_Priority2Code(self, value):
        # Validate type Priority2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HIGH', 'NORM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Priority2Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InstrPrty is not None or
            self.SvcLvl is not None or
            self.LclInstrm is not None or
            self.CtgyPurp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentTypeInformation19', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentTypeInformation19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentTypeInformation19')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentTypeInformation19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentTypeInformation19'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentTypeInformation19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstrPrty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrPrty>%s</%sInstrPrty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstrPrty), input_name='InstrPrty')), namespace_, eol_))
        if self.SvcLvl is not None:
            self.SvcLvl.export(outfile, level, namespace_, name_='SvcLvl', pretty_print=pretty_print)
        if self.LclInstrm is not None:
            self.LclInstrm.export(outfile, level, namespace_, name_='LclInstrm', pretty_print=pretty_print)
        if self.CtgyPurp is not None:
            self.CtgyPurp.export(outfile, level, namespace_, name_='CtgyPurp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstrPrty':
            InstrPrty_ = child_.text
            InstrPrty_ = self.gds_validate_string(InstrPrty_, node, 'InstrPrty')
            self.InstrPrty = InstrPrty_
            # validate type Priority2Code
            self.validate_Priority2Code(self.InstrPrty)
        elif nodeName_ == 'SvcLvl':
            obj_ = ServiceLevel8Choice.factory()
            obj_.build(child_)
            self.SvcLvl = obj_
            obj_.original_tagname_ = 'SvcLvl'
        elif nodeName_ == 'LclInstrm':
            obj_ = LocalInstrument2Choice.factory()
            obj_.build(child_)
            self.LclInstrm = obj_
            obj_.original_tagname_ = 'LclInstrm'
        elif nodeName_ == 'CtgyPurp':
            obj_ = CategoryPurpose1Choice.factory()
            obj_.build(child_)
            self.CtgyPurp = obj_
            obj_.original_tagname_ = 'CtgyPurp'
# end class PaymentTypeInformation19


class PersonIdentification5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DtAndPlcOfBirth=None, Othr=None):
        self.original_tagname_ = None
        self.DtAndPlcOfBirth = DtAndPlcOfBirth
        if Othr is None:
            self.Othr = []
        else:
            self.Othr = Othr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonIdentification5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonIdentification5.subclass:
            return PersonIdentification5.subclass(*args_, **kwargs_)
        else:
            return PersonIdentification5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DtAndPlcOfBirth(self): return self.DtAndPlcOfBirth
    def set_DtAndPlcOfBirth(self, DtAndPlcOfBirth): self.DtAndPlcOfBirth = DtAndPlcOfBirth
    def get_Othr(self): return self.Othr
    def set_Othr(self, Othr): self.Othr = Othr
    def add_Othr(self, value): self.Othr.append(value)
    def insert_Othr_at(self, index, value): self.Othr.insert(index, value)
    def replace_Othr_at(self, index, value): self.Othr[index] = value
    def hasContent_(self):
        if (
            self.DtAndPlcOfBirth is not None or
            self.Othr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonIdentification5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonIdentification5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonIdentification5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonIdentification5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonIdentification5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PersonIdentification5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DtAndPlcOfBirth is not None:
            self.DtAndPlcOfBirth.export(outfile, level, namespace_, name_='DtAndPlcOfBirth', pretty_print=pretty_print)
        for Othr_ in self.Othr:
            Othr_.export(outfile, level, namespace_, name_='Othr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DtAndPlcOfBirth':
            obj_ = DateAndPlaceOfBirth.factory()
            obj_.build(child_)
            self.DtAndPlcOfBirth = obj_
            obj_.original_tagname_ = 'DtAndPlcOfBirth'
        elif nodeName_ == 'Othr':
            obj_ = GenericPersonIdentification1.factory()
            obj_.build(child_)
            self.Othr.append(obj_)
            obj_.original_tagname_ = 'Othr'
# end class PersonIdentification5


class PersonIdentificationSchemeName1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalPersonIdentification1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonIdentificationSchemeName1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonIdentificationSchemeName1Choice.subclass:
            return PersonIdentificationSchemeName1Choice.subclass(*args_, **kwargs_)
        else:
            return PersonIdentificationSchemeName1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalPersonIdentification1Code(self, value):
        # Validate type ExternalPersonIdentification1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalPersonIdentification1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalPersonIdentification1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonIdentificationSchemeName1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonIdentificationSchemeName1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonIdentificationSchemeName1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonIdentificationSchemeName1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonIdentificationSchemeName1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PersonIdentificationSchemeName1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalPersonIdentification1Code
            self.validate_ExternalPersonIdentification1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class PersonIdentificationSchemeName1Choice


class PostalAddress6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdrTp=None, Dept=None, SubDept=None, StrtNm=None, BldgNb=None, PstCd=None, TwnNm=None, CtrySubDvsn=None, Ctry=None, AdrLine=None):
        self.original_tagname_ = None
        self.AdrTp = AdrTp
        self.validate_AddressType2Code(self.AdrTp)
        self.Dept = Dept
        self.validate_Max70Text(self.Dept)
        self.SubDept = SubDept
        self.validate_Max70Text(self.SubDept)
        self.StrtNm = StrtNm
        self.validate_Max70Text(self.StrtNm)
        self.BldgNb = BldgNb
        self.validate_Max16Text(self.BldgNb)
        self.PstCd = PstCd
        self.validate_Max16Text(self.PstCd)
        self.TwnNm = TwnNm
        self.validate_Max35Text(self.TwnNm)
        self.CtrySubDvsn = CtrySubDvsn
        self.validate_Max35Text(self.CtrySubDvsn)
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        if AdrLine is None:
            self.AdrLine = []
        else:
            self.AdrLine = AdrLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PostalAddress6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PostalAddress6.subclass:
            return PostalAddress6.subclass(*args_, **kwargs_)
        else:
            return PostalAddress6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdrTp(self): return self.AdrTp
    def set_AdrTp(self, AdrTp): self.AdrTp = AdrTp
    def get_Dept(self): return self.Dept
    def set_Dept(self, Dept): self.Dept = Dept
    def get_SubDept(self): return self.SubDept
    def set_SubDept(self, SubDept): self.SubDept = SubDept
    def get_StrtNm(self): return self.StrtNm
    def set_StrtNm(self, StrtNm): self.StrtNm = StrtNm
    def get_BldgNb(self): return self.BldgNb
    def set_BldgNb(self, BldgNb): self.BldgNb = BldgNb
    def get_PstCd(self): return self.PstCd
    def set_PstCd(self, PstCd): self.PstCd = PstCd
    def get_TwnNm(self): return self.TwnNm
    def set_TwnNm(self, TwnNm): self.TwnNm = TwnNm
    def get_CtrySubDvsn(self): return self.CtrySubDvsn
    def set_CtrySubDvsn(self, CtrySubDvsn): self.CtrySubDvsn = CtrySubDvsn
    def get_Ctry(self): return self.Ctry
    def set_Ctry(self, Ctry): self.Ctry = Ctry
    def get_AdrLine(self): return self.AdrLine
    def set_AdrLine(self, AdrLine): self.AdrLine = AdrLine
    def add_AdrLine(self, value): self.AdrLine.append(value)
    def insert_AdrLine_at(self, index, value): self.AdrLine.insert(index, value)
    def replace_AdrLine_at(self, index, value): self.AdrLine[index] = value
    def validate_AddressType2Code(self, value):
        # Validate type AddressType2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADDR', 'PBOX', 'HOME', 'BIZZ', 'MLTO', 'DLVY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressType2Code' % {"value" : value.encode("utf-8")} )
    def validate_Max70Text(self, value):
        # Validate type Max70Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max70Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max70Text' % {"value" : value.encode("utf-8")} )
    def validate_Max16Text(self, value):
        # Validate type Max16Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max16Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max16Text' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.AdrTp is not None or
            self.Dept is not None or
            self.SubDept is not None or
            self.StrtNm is not None or
            self.BldgNb is not None or
            self.PstCd is not None or
            self.TwnNm is not None or
            self.CtrySubDvsn is not None or
            self.Ctry is not None or
            self.AdrLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PostalAddress6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PostalAddress6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostalAddress6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PostalAddress6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostalAddress6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PostalAddress6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdrTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdrTp>%s</%sAdrTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AdrTp), input_name='AdrTp')), namespace_, eol_))
        if self.Dept is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDept>%s</%sDept>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Dept), input_name='Dept')), namespace_, eol_))
        if self.SubDept is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubDept>%s</%sSubDept>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SubDept), input_name='SubDept')), namespace_, eol_))
        if self.StrtNm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStrtNm>%s</%sStrtNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StrtNm), input_name='StrtNm')), namespace_, eol_))
        if self.BldgNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBldgNb>%s</%sBldgNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BldgNb), input_name='BldgNb')), namespace_, eol_))
        if self.PstCd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPstCd>%s</%sPstCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PstCd), input_name='PstCd')), namespace_, eol_))
        if self.TwnNm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTwnNm>%s</%sTwnNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TwnNm), input_name='TwnNm')), namespace_, eol_))
        if self.CtrySubDvsn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtrySubDvsn>%s</%sCtrySubDvsn>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CtrySubDvsn), input_name='CtrySubDvsn')), namespace_, eol_))
        if self.Ctry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespace_, eol_))
        for AdrLine_ in self.AdrLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdrLine>%s</%sAdrLine>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(AdrLine_), input_name='AdrLine')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdrTp':
            AdrTp_ = child_.text
            AdrTp_ = self.gds_validate_string(AdrTp_, node, 'AdrTp')
            self.AdrTp = AdrTp_
            # validate type AddressType2Code
            self.validate_AddressType2Code(self.AdrTp)
        elif nodeName_ == 'Dept':
            Dept_ = child_.text
            Dept_ = self.gds_validate_string(Dept_, node, 'Dept')
            self.Dept = Dept_
            # validate type Max70Text
            self.validate_Max70Text(self.Dept)
        elif nodeName_ == 'SubDept':
            SubDept_ = child_.text
            SubDept_ = self.gds_validate_string(SubDept_, node, 'SubDept')
            self.SubDept = SubDept_
            # validate type Max70Text
            self.validate_Max70Text(self.SubDept)
        elif nodeName_ == 'StrtNm':
            StrtNm_ = child_.text
            StrtNm_ = self.gds_validate_string(StrtNm_, node, 'StrtNm')
            self.StrtNm = StrtNm_
            # validate type Max70Text
            self.validate_Max70Text(self.StrtNm)
        elif nodeName_ == 'BldgNb':
            BldgNb_ = child_.text
            BldgNb_ = self.gds_validate_string(BldgNb_, node, 'BldgNb')
            self.BldgNb = BldgNb_
            # validate type Max16Text
            self.validate_Max16Text(self.BldgNb)
        elif nodeName_ == 'PstCd':
            PstCd_ = child_.text
            PstCd_ = self.gds_validate_string(PstCd_, node, 'PstCd')
            self.PstCd = PstCd_
            # validate type Max16Text
            self.validate_Max16Text(self.PstCd)
        elif nodeName_ == 'TwnNm':
            TwnNm_ = child_.text
            TwnNm_ = self.gds_validate_string(TwnNm_, node, 'TwnNm')
            self.TwnNm = TwnNm_
            # validate type Max35Text
            self.validate_Max35Text(self.TwnNm)
        elif nodeName_ == 'CtrySubDvsn':
            CtrySubDvsn_ = child_.text
            CtrySubDvsn_ = self.gds_validate_string(CtrySubDvsn_, node, 'CtrySubDvsn')
            self.CtrySubDvsn = CtrySubDvsn_
            # validate type Max35Text
            self.validate_Max35Text(self.CtrySubDvsn)
        elif nodeName_ == 'Ctry':
            Ctry_ = child_.text
            Ctry_ = self.gds_validate_string(Ctry_, node, 'Ctry')
            self.Ctry = Ctry_
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
        elif nodeName_ == 'AdrLine':
            AdrLine_ = child_.text
            AdrLine_ = self.gds_validate_string(AdrLine_, node, 'AdrLine')
            self.AdrLine.append(AdrLine_)
            # validate type Max70Text
            self.validate_Max70Text(self.AdrLine[-1])
# end class PostalAddress6


class Purpose2Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalPurpose1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Purpose2Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Purpose2Choice.subclass:
            return Purpose2Choice.subclass(*args_, **kwargs_)
        else:
            return Purpose2Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalPurpose1Code(self, value):
        # Validate type ExternalPurpose1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalPurpose1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalPurpose1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Purpose2Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Purpose2Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Purpose2Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Purpose2Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Purpose2Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Purpose2Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalPurpose1Code
            self.validate_ExternalPurpose1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class Purpose2Choice


class ReferredDocumentInformation3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Nb=None, RltdDt=None):
        self.original_tagname_ = None
        self.Tp = Tp
        self.Nb = Nb
        self.validate_Max35Text(self.Nb)
        if isinstance(RltdDt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RltdDt, '%Y-%m-%d').date()
        else:
            initvalue_ = RltdDt
        self.RltdDt = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentInformation3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentInformation3.subclass:
            return ReferredDocumentInformation3.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentInformation3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Nb(self): return self.Nb
    def set_Nb(self, Nb): self.Nb = Nb
    def get_RltdDt(self): return self.RltdDt
    def set_RltdDt(self, RltdDt): self.RltdDt = RltdDt
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Tp is not None or
            self.Nb is not None or
            self.RltdDt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferredDocumentInformation3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferredDocumentInformation3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferredDocumentInformation3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferredDocumentInformation3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferredDocumentInformation3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferredDocumentInformation3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            self.Tp.export(outfile, level, namespace_, name_='Tp', pretty_print=pretty_print)
        if self.Nb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNb>%s</%sNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nb), input_name='Nb')), namespace_, eol_))
        if self.RltdDt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRltdDt>%s</%sRltdDt>%s' % (namespace_, self.gds_format_date(self.RltdDt, input_name='RltdDt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tp':
            obj_ = ReferredDocumentType2.factory()
            obj_.build(child_)
            self.Tp = obj_
            obj_.original_tagname_ = 'Tp'
        elif nodeName_ == 'Nb':
            Nb_ = child_.text
            Nb_ = self.gds_validate_string(Nb_, node, 'Nb')
            self.Nb = Nb_
            # validate type Max35Text
            self.validate_Max35Text(self.Nb)
        elif nodeName_ == 'RltdDt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RltdDt = dval_
            # validate type ISODate
            self.validate_ISODate(self.RltdDt)
# end class ReferredDocumentInformation3


class ReferredDocumentType1Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_DocumentType5Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentType1Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentType1Choice.subclass:
            return ReferredDocumentType1Choice.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentType1Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_DocumentType5Code(self, value):
        # Validate type DocumentType5Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MSIN', 'CNFA', 'DNFA', 'CINV', 'CREN', 'DEBN', 'HIRI', 'SBIN', 'CMCN', 'SOAC', 'DISP', 'BOLD', 'VCHR', 'AROI', 'TSUT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocumentType5Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferredDocumentType1Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferredDocumentType1Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferredDocumentType1Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferredDocumentType1Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferredDocumentType1Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferredDocumentType1Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type DocumentType5Code
            self.validate_DocumentType5Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ReferredDocumentType1Choice


class ReferredDocumentType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CdOrPrtry=None, Issr=None):
        self.original_tagname_ = None
        self.CdOrPrtry = CdOrPrtry
        self.Issr = Issr
        self.validate_Max35Text(self.Issr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferredDocumentType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferredDocumentType2.subclass:
            return ReferredDocumentType2.subclass(*args_, **kwargs_)
        else:
            return ReferredDocumentType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CdOrPrtry(self): return self.CdOrPrtry
    def set_CdOrPrtry(self, CdOrPrtry): self.CdOrPrtry = CdOrPrtry
    def get_Issr(self): return self.Issr
    def set_Issr(self, Issr): self.Issr = Issr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CdOrPrtry is not None or
            self.Issr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferredDocumentType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferredDocumentType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferredDocumentType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferredDocumentType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferredDocumentType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferredDocumentType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdOrPrtry is not None:
            self.CdOrPrtry.export(outfile, level, namespace_, name_='CdOrPrtry', pretty_print=pretty_print)
        if self.Issr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssr>%s</%sIssr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Issr), input_name='Issr')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CdOrPrtry':
            obj_ = ReferredDocumentType1Choice.factory()
            obj_.build(child_)
            self.CdOrPrtry = obj_
            obj_.original_tagname_ = 'CdOrPrtry'
        elif nodeName_ == 'Issr':
            Issr_ = child_.text
            Issr_ = self.gds_validate_string(Issr_, node, 'Issr')
            self.Issr = Issr_
            # validate type Max35Text
            self.validate_Max35Text(self.Issr)
# end class ReferredDocumentType2


class RegulatoryAuthority2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Nm=None, Ctry=None):
        self.original_tagname_ = None
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatoryAuthority2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatoryAuthority2.subclass:
            return RegulatoryAuthority2.subclass(*args_, **kwargs_)
        else:
            return RegulatoryAuthority2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def get_Ctry(self): return self.Ctry
    def set_Ctry(self, Ctry): self.Ctry = Ctry
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def hasContent_(self):
        if (
            self.Nm is not None or
            self.Ctry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegulatoryAuthority2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegulatoryAuthority2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulatoryAuthority2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegulatoryAuthority2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegulatoryAuthority2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegulatoryAuthority2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
        if self.Ctry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
        elif nodeName_ == 'Ctry':
            Ctry_ = child_.text
            Ctry_ = self.gds_validate_string(Ctry_, node, 'Ctry')
            self.Ctry = Ctry_
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
# end class RegulatoryAuthority2


class RegulatoryReporting3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DbtCdtRptgInd=None, Authrty=None, Dtls=None):
        self.original_tagname_ = None
        self.DbtCdtRptgInd = DbtCdtRptgInd
        self.validate_RegulatoryReportingType1Code(self.DbtCdtRptgInd)
        self.Authrty = Authrty
        if Dtls is None:
            self.Dtls = []
        else:
            self.Dtls = Dtls
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatoryReporting3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatoryReporting3.subclass:
            return RegulatoryReporting3.subclass(*args_, **kwargs_)
        else:
            return RegulatoryReporting3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DbtCdtRptgInd(self): return self.DbtCdtRptgInd
    def set_DbtCdtRptgInd(self, DbtCdtRptgInd): self.DbtCdtRptgInd = DbtCdtRptgInd
    def get_Authrty(self): return self.Authrty
    def set_Authrty(self, Authrty): self.Authrty = Authrty
    def get_Dtls(self): return self.Dtls
    def set_Dtls(self, Dtls): self.Dtls = Dtls
    def add_Dtls(self, value): self.Dtls.append(value)
    def insert_Dtls_at(self, index, value): self.Dtls.insert(index, value)
    def replace_Dtls_at(self, index, value): self.Dtls[index] = value
    def validate_RegulatoryReportingType1Code(self, value):
        # Validate type RegulatoryReportingType1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CRED', 'DEBT', 'BOTH']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RegulatoryReportingType1Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DbtCdtRptgInd is not None or
            self.Authrty is not None or
            self.Dtls
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegulatoryReporting3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegulatoryReporting3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulatoryReporting3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegulatoryReporting3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegulatoryReporting3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegulatoryReporting3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DbtCdtRptgInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDbtCdtRptgInd>%s</%sDbtCdtRptgInd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DbtCdtRptgInd), input_name='DbtCdtRptgInd')), namespace_, eol_))
        if self.Authrty is not None:
            self.Authrty.export(outfile, level, namespace_, name_='Authrty', pretty_print=pretty_print)
        for Dtls_ in self.Dtls:
            Dtls_.export(outfile, level, namespace_, name_='Dtls', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DbtCdtRptgInd':
            DbtCdtRptgInd_ = child_.text
            DbtCdtRptgInd_ = self.gds_validate_string(DbtCdtRptgInd_, node, 'DbtCdtRptgInd')
            self.DbtCdtRptgInd = DbtCdtRptgInd_
            # validate type RegulatoryReportingType1Code
            self.validate_RegulatoryReportingType1Code(self.DbtCdtRptgInd)
        elif nodeName_ == 'Authrty':
            obj_ = RegulatoryAuthority2.factory()
            obj_.build(child_)
            self.Authrty = obj_
            obj_.original_tagname_ = 'Authrty'
        elif nodeName_ == 'Dtls':
            obj_ = StructuredRegulatoryReporting3.factory()
            obj_.build(child_)
            self.Dtls.append(obj_)
            obj_.original_tagname_ = 'Dtls'
# end class RegulatoryReporting3


class RemittanceAmount1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DuePyblAmt=None, DscntApldAmt=None, CdtNoteAmt=None, TaxAmt=None, AdjstmntAmtAndRsn=None, RmtdAmt=None):
        self.original_tagname_ = None
        self.DuePyblAmt = DuePyblAmt
        self.DscntApldAmt = DscntApldAmt
        self.CdtNoteAmt = CdtNoteAmt
        self.TaxAmt = TaxAmt
        if AdjstmntAmtAndRsn is None:
            self.AdjstmntAmtAndRsn = []
        else:
            self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
        self.RmtdAmt = RmtdAmt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceAmount1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceAmount1.subclass:
            return RemittanceAmount1.subclass(*args_, **kwargs_)
        else:
            return RemittanceAmount1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DuePyblAmt(self): return self.DuePyblAmt
    def set_DuePyblAmt(self, DuePyblAmt): self.DuePyblAmt = DuePyblAmt
    def get_DscntApldAmt(self): return self.DscntApldAmt
    def set_DscntApldAmt(self, DscntApldAmt): self.DscntApldAmt = DscntApldAmt
    def get_CdtNoteAmt(self): return self.CdtNoteAmt
    def set_CdtNoteAmt(self, CdtNoteAmt): self.CdtNoteAmt = CdtNoteAmt
    def get_TaxAmt(self): return self.TaxAmt
    def set_TaxAmt(self, TaxAmt): self.TaxAmt = TaxAmt
    def get_AdjstmntAmtAndRsn(self): return self.AdjstmntAmtAndRsn
    def set_AdjstmntAmtAndRsn(self, AdjstmntAmtAndRsn): self.AdjstmntAmtAndRsn = AdjstmntAmtAndRsn
    def add_AdjstmntAmtAndRsn(self, value): self.AdjstmntAmtAndRsn.append(value)
    def insert_AdjstmntAmtAndRsn_at(self, index, value): self.AdjstmntAmtAndRsn.insert(index, value)
    def replace_AdjstmntAmtAndRsn_at(self, index, value): self.AdjstmntAmtAndRsn[index] = value
    def get_RmtdAmt(self): return self.RmtdAmt
    def set_RmtdAmt(self, RmtdAmt): self.RmtdAmt = RmtdAmt
    def hasContent_(self):
        if (
            self.DuePyblAmt is not None or
            self.DscntApldAmt is not None or
            self.CdtNoteAmt is not None or
            self.TaxAmt is not None or
            self.AdjstmntAmtAndRsn or
            self.RmtdAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RemittanceAmount1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceAmount1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemittanceAmount1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RemittanceAmount1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RemittanceAmount1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RemittanceAmount1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DuePyblAmt is not None:
            self.DuePyblAmt.export(outfile, level, namespace_, name_='DuePyblAmt', pretty_print=pretty_print)
        if self.DscntApldAmt is not None:
            self.DscntApldAmt.export(outfile, level, namespace_, name_='DscntApldAmt', pretty_print=pretty_print)
        if self.CdtNoteAmt is not None:
            self.CdtNoteAmt.export(outfile, level, namespace_, name_='CdtNoteAmt', pretty_print=pretty_print)
        if self.TaxAmt is not None:
            self.TaxAmt.export(outfile, level, namespace_, name_='TaxAmt', pretty_print=pretty_print)
        for AdjstmntAmtAndRsn_ in self.AdjstmntAmtAndRsn:
            AdjstmntAmtAndRsn_.export(outfile, level, namespace_, name_='AdjstmntAmtAndRsn', pretty_print=pretty_print)
        if self.RmtdAmt is not None:
            self.RmtdAmt.export(outfile, level, namespace_, name_='RmtdAmt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DuePyblAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.DuePyblAmt = obj_
            obj_.original_tagname_ = 'DuePyblAmt'
        elif nodeName_ == 'DscntApldAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.DscntApldAmt = obj_
            obj_.original_tagname_ = 'DscntApldAmt'
        elif nodeName_ == 'CdtNoteAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.CdtNoteAmt = obj_
            obj_.original_tagname_ = 'CdtNoteAmt'
        elif nodeName_ == 'TaxAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.TaxAmt = obj_
            obj_.original_tagname_ = 'TaxAmt'
        elif nodeName_ == 'AdjstmntAmtAndRsn':
            obj_ = DocumentAdjustment1.factory()
            obj_.build(child_)
            self.AdjstmntAmtAndRsn.append(obj_)
            obj_.original_tagname_ = 'AdjstmntAmtAndRsn'
        elif nodeName_ == 'RmtdAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.RmtdAmt = obj_
            obj_.original_tagname_ = 'RmtdAmt'
# end class RemittanceAmount1


class RemittanceInformation5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Ustrd=None, Strd=None):
        self.original_tagname_ = None
        if Ustrd is None:
            self.Ustrd = []
        else:
            self.Ustrd = Ustrd
        if Strd is None:
            self.Strd = []
        else:
            self.Strd = Strd
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceInformation5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceInformation5.subclass:
            return RemittanceInformation5.subclass(*args_, **kwargs_)
        else:
            return RemittanceInformation5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ustrd(self): return self.Ustrd
    def set_Ustrd(self, Ustrd): self.Ustrd = Ustrd
    def add_Ustrd(self, value): self.Ustrd.append(value)
    def insert_Ustrd_at(self, index, value): self.Ustrd.insert(index, value)
    def replace_Ustrd_at(self, index, value): self.Ustrd[index] = value
    def get_Strd(self): return self.Strd
    def set_Strd(self, Strd): self.Strd = Strd
    def add_Strd(self, value): self.Strd.append(value)
    def insert_Strd_at(self, index, value): self.Strd.insert(index, value)
    def replace_Strd_at(self, index, value): self.Strd[index] = value
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Ustrd or
            self.Strd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RemittanceInformation5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceInformation5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemittanceInformation5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RemittanceInformation5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RemittanceInformation5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RemittanceInformation5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Ustrd_ in self.Ustrd:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUstrd>%s</%sUstrd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Ustrd_), input_name='Ustrd')), namespace_, eol_))
        for Strd_ in self.Strd:
            Strd_.export(outfile, level, namespace_, name_='Strd', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ustrd':
            Ustrd_ = child_.text
            Ustrd_ = self.gds_validate_string(Ustrd_, node, 'Ustrd')
            self.Ustrd.append(Ustrd_)
            # validate type Max140Text
            self.validate_Max140Text(self.Ustrd[-1])
        elif nodeName_ == 'Strd':
            obj_ = StructuredRemittanceInformation7.factory()
            obj_.build(child_)
            self.Strd.append(obj_)
            obj_.original_tagname_ = 'Strd'
# end class RemittanceInformation5


class RemittanceLocation2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RmtId=None, RmtLctnMtd=None, RmtLctnElctrncAdr=None, RmtLctnPstlAdr=None):
        self.original_tagname_ = None
        self.RmtId = RmtId
        self.validate_Max35Text(self.RmtId)
        self.RmtLctnMtd = RmtLctnMtd
        self.validate_RemittanceLocationMethod2Code(self.RmtLctnMtd)
        self.RmtLctnElctrncAdr = RmtLctnElctrncAdr
        self.validate_Max2048Text(self.RmtLctnElctrncAdr)
        self.RmtLctnPstlAdr = RmtLctnPstlAdr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemittanceLocation2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemittanceLocation2.subclass:
            return RemittanceLocation2.subclass(*args_, **kwargs_)
        else:
            return RemittanceLocation2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RmtId(self): return self.RmtId
    def set_RmtId(self, RmtId): self.RmtId = RmtId
    def get_RmtLctnMtd(self): return self.RmtLctnMtd
    def set_RmtLctnMtd(self, RmtLctnMtd): self.RmtLctnMtd = RmtLctnMtd
    def get_RmtLctnElctrncAdr(self): return self.RmtLctnElctrncAdr
    def set_RmtLctnElctrncAdr(self, RmtLctnElctrncAdr): self.RmtLctnElctrncAdr = RmtLctnElctrncAdr
    def get_RmtLctnPstlAdr(self): return self.RmtLctnPstlAdr
    def set_RmtLctnPstlAdr(self, RmtLctnPstlAdr): self.RmtLctnPstlAdr = RmtLctnPstlAdr
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_RemittanceLocationMethod2Code(self, value):
        # Validate type RemittanceLocationMethod2Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAXI', 'EDIC', 'URID', 'EMAL', 'POST', 'SMSM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RemittanceLocationMethod2Code' % {"value" : value.encode("utf-8")} )
    def validate_Max2048Text(self, value):
        # Validate type Max2048Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2048:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max2048Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max2048Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RmtId is not None or
            self.RmtLctnMtd is not None or
            self.RmtLctnElctrncAdr is not None or
            self.RmtLctnPstlAdr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RemittanceLocation2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemittanceLocation2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemittanceLocation2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RemittanceLocation2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RemittanceLocation2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RemittanceLocation2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RmtId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRmtId>%s</%sRmtId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RmtId), input_name='RmtId')), namespace_, eol_))
        if self.RmtLctnMtd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRmtLctnMtd>%s</%sRmtLctnMtd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RmtLctnMtd), input_name='RmtLctnMtd')), namespace_, eol_))
        if self.RmtLctnElctrncAdr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRmtLctnElctrncAdr>%s</%sRmtLctnElctrncAdr>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RmtLctnElctrncAdr), input_name='RmtLctnElctrncAdr')), namespace_, eol_))
        if self.RmtLctnPstlAdr is not None:
            self.RmtLctnPstlAdr.export(outfile, level, namespace_, name_='RmtLctnPstlAdr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RmtId':
            RmtId_ = child_.text
            RmtId_ = self.gds_validate_string(RmtId_, node, 'RmtId')
            self.RmtId = RmtId_
            # validate type Max35Text
            self.validate_Max35Text(self.RmtId)
        elif nodeName_ == 'RmtLctnMtd':
            RmtLctnMtd_ = child_.text
            RmtLctnMtd_ = self.gds_validate_string(RmtLctnMtd_, node, 'RmtLctnMtd')
            self.RmtLctnMtd = RmtLctnMtd_
            # validate type RemittanceLocationMethod2Code
            self.validate_RemittanceLocationMethod2Code(self.RmtLctnMtd)
        elif nodeName_ == 'RmtLctnElctrncAdr':
            RmtLctnElctrncAdr_ = child_.text
            RmtLctnElctrncAdr_ = self.gds_validate_string(RmtLctnElctrncAdr_, node, 'RmtLctnElctrncAdr')
            self.RmtLctnElctrncAdr = RmtLctnElctrncAdr_
            # validate type Max2048Text
            self.validate_Max2048Text(self.RmtLctnElctrncAdr)
        elif nodeName_ == 'RmtLctnPstlAdr':
            obj_ = NameAndAddress10.factory()
            obj_.build(child_)
            self.RmtLctnPstlAdr = obj_
            obj_.original_tagname_ = 'RmtLctnPstlAdr'
# end class RemittanceLocation2


class ServiceLevel8Choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cd=None, Prtry=None):
        self.original_tagname_ = None
        self.Cd = Cd
        self.validate_ExternalServiceLevel1Code(self.Cd)
        self.Prtry = Prtry
        self.validate_Max35Text(self.Prtry)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceLevel8Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceLevel8Choice.subclass:
            return ServiceLevel8Choice.subclass(*args_, **kwargs_)
        else:
            return ServiceLevel8Choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Prtry(self): return self.Prtry
    def set_Prtry(self, Prtry): self.Prtry = Prtry
    def validate_ExternalServiceLevel1Code(self, value):
        # Validate type ExternalServiceLevel1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExternalServiceLevel1Code' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExternalServiceLevel1Code' % {"value" : value.encode("utf-8")} )
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Cd is not None or
            self.Prtry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceLevel8Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceLevel8Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceLevel8Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceLevel8Choice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceLevel8Choice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceLevel8Choice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Prtry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrtry>%s</%sPrtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Prtry), input_name='Prtry')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type ExternalServiceLevel1Code
            self.validate_ExternalServiceLevel1Code(self.Cd)
        elif nodeName_ == 'Prtry':
            Prtry_ = child_.text
            Prtry_ = self.gds_validate_string(Prtry_, node, 'Prtry')
            self.Prtry = Prtry_
            # validate type Max35Text
            self.validate_Max35Text(self.Prtry)
# end class ServiceLevel8Choice


class StructuredRegulatoryReporting3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Dt=None, Ctry=None, Cd=None, Amt=None, Inf=None):
        self.original_tagname_ = None
        self.Tp = Tp
        self.validate_Max35Text(self.Tp)
        if isinstance(Dt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Dt, '%Y-%m-%d').date()
        else:
            initvalue_ = Dt
        self.Dt = initvalue_
        self.Ctry = Ctry
        self.validate_CountryCode(self.Ctry)
        self.Cd = Cd
        self.validate_Max10Text(self.Cd)
        self.Amt = Amt
        if Inf is None:
            self.Inf = []
        else:
            self.Inf = Inf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructuredRegulatoryReporting3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructuredRegulatoryReporting3.subclass:
            return StructuredRegulatoryReporting3.subclass(*args_, **kwargs_)
        else:
            return StructuredRegulatoryReporting3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Dt(self): return self.Dt
    def set_Dt(self, Dt): self.Dt = Dt
    def get_Ctry(self): return self.Ctry
    def set_Ctry(self, Ctry): self.Ctry = Ctry
    def get_Cd(self): return self.Cd
    def set_Cd(self, Cd): self.Cd = Cd
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def get_Inf(self): return self.Inf
    def set_Inf(self, Inf): self.Inf = Inf
    def add_Inf(self, value): self.Inf.append(value)
    def insert_Inf_at(self, index, value): self.Inf.insert(index, value)
    def replace_Inf_at(self, index, value): self.Inf[index] = value
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CountryCode_patterns_, ))
    validate_CountryCode_patterns_ = [['^[A-Z]{2,2}$']]
    def validate_Max10Text(self, value):
        # Validate type Max10Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max10Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max10Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Tp is not None or
            self.Dt is not None or
            self.Ctry is not None or
            self.Cd is not None or
            self.Amt is not None or
            self.Inf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StructuredRegulatoryReporting3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StructuredRegulatoryReporting3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuredRegulatoryReporting3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StructuredRegulatoryReporting3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StructuredRegulatoryReporting3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StructuredRegulatoryReporting3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTp>%s</%sTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Tp), input_name='Tp')), namespace_, eol_))
        if self.Dt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDt>%s</%sDt>%s' % (namespace_, self.gds_format_date(self.Dt, input_name='Dt'), namespace_, eol_))
        if self.Ctry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtry>%s</%sCtry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctry), input_name='Ctry')), namespace_, eol_))
        if self.Cd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCd>%s</%sCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Cd), input_name='Cd')), namespace_, eol_))
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
        for Inf_ in self.Inf:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInf>%s</%sInf>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(Inf_), input_name='Inf')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tp':
            Tp_ = child_.text
            Tp_ = self.gds_validate_string(Tp_, node, 'Tp')
            self.Tp = Tp_
            # validate type Max35Text
            self.validate_Max35Text(self.Tp)
        elif nodeName_ == 'Dt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Dt = dval_
            # validate type ISODate
            self.validate_ISODate(self.Dt)
        elif nodeName_ == 'Ctry':
            Ctry_ = child_.text
            Ctry_ = self.gds_validate_string(Ctry_, node, 'Ctry')
            self.Ctry = Ctry_
            # validate type CountryCode
            self.validate_CountryCode(self.Ctry)
        elif nodeName_ == 'Cd':
            Cd_ = child_.text
            Cd_ = self.gds_validate_string(Cd_, node, 'Cd')
            self.Cd = Cd_
            # validate type Max10Text
            self.validate_Max10Text(self.Cd)
        elif nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
        elif nodeName_ == 'Inf':
            Inf_ = child_.text
            Inf_ = self.gds_validate_string(Inf_, node, 'Inf')
            self.Inf.append(Inf_)
            # validate type Max35Text
            self.validate_Max35Text(self.Inf[-1])
# end class StructuredRegulatoryReporting3


class StructuredRemittanceInformation7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RfrdDocInf=None, RfrdDocAmt=None, CdtrRefInf=None, Invcr=None, Invcee=None, AddtlRmtInf=None):
        self.original_tagname_ = None
        if RfrdDocInf is None:
            self.RfrdDocInf = []
        else:
            self.RfrdDocInf = RfrdDocInf
        self.RfrdDocAmt = RfrdDocAmt
        self.CdtrRefInf = CdtrRefInf
        self.Invcr = Invcr
        self.Invcee = Invcee
        if AddtlRmtInf is None:
            self.AddtlRmtInf = []
        else:
            self.AddtlRmtInf = AddtlRmtInf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructuredRemittanceInformation7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructuredRemittanceInformation7.subclass:
            return StructuredRemittanceInformation7.subclass(*args_, **kwargs_)
        else:
            return StructuredRemittanceInformation7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RfrdDocInf(self): return self.RfrdDocInf
    def set_RfrdDocInf(self, RfrdDocInf): self.RfrdDocInf = RfrdDocInf
    def add_RfrdDocInf(self, value): self.RfrdDocInf.append(value)
    def insert_RfrdDocInf_at(self, index, value): self.RfrdDocInf.insert(index, value)
    def replace_RfrdDocInf_at(self, index, value): self.RfrdDocInf[index] = value
    def get_RfrdDocAmt(self): return self.RfrdDocAmt
    def set_RfrdDocAmt(self, RfrdDocAmt): self.RfrdDocAmt = RfrdDocAmt
    def get_CdtrRefInf(self): return self.CdtrRefInf
    def set_CdtrRefInf(self, CdtrRefInf): self.CdtrRefInf = CdtrRefInf
    def get_Invcr(self): return self.Invcr
    def set_Invcr(self, Invcr): self.Invcr = Invcr
    def get_Invcee(self): return self.Invcee
    def set_Invcee(self, Invcee): self.Invcee = Invcee
    def get_AddtlRmtInf(self): return self.AddtlRmtInf
    def set_AddtlRmtInf(self, AddtlRmtInf): self.AddtlRmtInf = AddtlRmtInf
    def add_AddtlRmtInf(self, value): self.AddtlRmtInf.append(value)
    def insert_AddtlRmtInf_at(self, index, value): self.AddtlRmtInf.insert(index, value)
    def replace_AddtlRmtInf_at(self, index, value): self.AddtlRmtInf[index] = value
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RfrdDocInf or
            self.RfrdDocAmt is not None or
            self.CdtrRefInf is not None or
            self.Invcr is not None or
            self.Invcee is not None or
            self.AddtlRmtInf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StructuredRemittanceInformation7', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StructuredRemittanceInformation7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuredRemittanceInformation7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StructuredRemittanceInformation7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StructuredRemittanceInformation7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StructuredRemittanceInformation7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RfrdDocInf_ in self.RfrdDocInf:
            RfrdDocInf_.export(outfile, level, namespace_, name_='RfrdDocInf', pretty_print=pretty_print)
        if self.RfrdDocAmt is not None:
            self.RfrdDocAmt.export(outfile, level, namespace_, name_='RfrdDocAmt', pretty_print=pretty_print)
        if self.CdtrRefInf is not None:
            self.CdtrRefInf.export(outfile, level, namespace_, name_='CdtrRefInf', pretty_print=pretty_print)
        if self.Invcr is not None:
            self.Invcr.export(outfile, level, namespace_, name_='Invcr', pretty_print=pretty_print)
        if self.Invcee is not None:
            self.Invcee.export(outfile, level, namespace_, name_='Invcee', pretty_print=pretty_print)
        for AddtlRmtInf_ in self.AddtlRmtInf:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddtlRmtInf>%s</%sAddtlRmtInf>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(AddtlRmtInf_), input_name='AddtlRmtInf')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RfrdDocInf':
            obj_ = ReferredDocumentInformation3.factory()
            obj_.build(child_)
            self.RfrdDocInf.append(obj_)
            obj_.original_tagname_ = 'RfrdDocInf'
        elif nodeName_ == 'RfrdDocAmt':
            obj_ = RemittanceAmount1.factory()
            obj_.build(child_)
            self.RfrdDocAmt = obj_
            obj_.original_tagname_ = 'RfrdDocAmt'
        elif nodeName_ == 'CdtrRefInf':
            obj_ = CreditorReferenceInformation2.factory()
            obj_.build(child_)
            self.CdtrRefInf = obj_
            obj_.original_tagname_ = 'CdtrRefInf'
        elif nodeName_ == 'Invcr':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.Invcr = obj_
            obj_.original_tagname_ = 'Invcr'
        elif nodeName_ == 'Invcee':
            obj_ = PartyIdentification32.factory()
            obj_.build(child_)
            self.Invcee = obj_
            obj_.original_tagname_ = 'Invcee'
        elif nodeName_ == 'AddtlRmtInf':
            AddtlRmtInf_ = child_.text
            AddtlRmtInf_ = self.gds_validate_string(AddtlRmtInf_, node, 'AddtlRmtInf')
            self.AddtlRmtInf.append(AddtlRmtInf_)
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlRmtInf[-1])
# end class StructuredRemittanceInformation7


class TaxAmount1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Rate=None, TaxblBaseAmt=None, TtlAmt=None, Dtls=None):
        self.original_tagname_ = None
        self.Rate = Rate
        self.validate_PercentageRate(self.Rate)
        self.TaxblBaseAmt = TaxblBaseAmt
        self.TtlAmt = TtlAmt
        if Dtls is None:
            self.Dtls = []
        else:
            self.Dtls = Dtls
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxAmount1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxAmount1.subclass:
            return TaxAmount1.subclass(*args_, **kwargs_)
        else:
            return TaxAmount1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Rate(self): return self.Rate
    def set_Rate(self, Rate): self.Rate = Rate
    def get_TaxblBaseAmt(self): return self.TaxblBaseAmt
    def set_TaxblBaseAmt(self, TaxblBaseAmt): self.TaxblBaseAmt = TaxblBaseAmt
    def get_TtlAmt(self): return self.TtlAmt
    def set_TtlAmt(self, TtlAmt): self.TtlAmt = TtlAmt
    def get_Dtls(self): return self.Dtls
    def set_Dtls(self, Dtls): self.Dtls = Dtls
    def add_Dtls(self, value): self.Dtls.append(value)
    def insert_Dtls_at(self, index, value): self.Dtls.insert(index, value)
    def replace_Dtls_at(self, index, value): self.Dtls[index] = value
    def validate_PercentageRate(self, value):
        # Validate type PercentageRate, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PercentageRate' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Rate is not None or
            self.TaxblBaseAmt is not None or
            self.TtlAmt is not None or
            self.Dtls
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxAmount1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxAmount1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxAmount1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxAmount1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxAmount1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxAmount1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRate>%s</%sRate>%s' % (namespace_, self.gds_format_float(self.Rate, input_name='Rate'), namespace_, eol_))
        if self.TaxblBaseAmt is not None:
            self.TaxblBaseAmt.export(outfile, level, namespace_, name_='TaxblBaseAmt', pretty_print=pretty_print)
        if self.TtlAmt is not None:
            self.TtlAmt.export(outfile, level, namespace_, name_='TtlAmt', pretty_print=pretty_print)
        for Dtls_ in self.Dtls:
            Dtls_.export(outfile, level, namespace_, name_='Dtls', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Rate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Rate')
            self.Rate = fval_
            # validate type PercentageRate
            self.validate_PercentageRate(self.Rate)
        elif nodeName_ == 'TaxblBaseAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.TaxblBaseAmt = obj_
            obj_.original_tagname_ = 'TaxblBaseAmt'
        elif nodeName_ == 'TtlAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.TtlAmt = obj_
            obj_.original_tagname_ = 'TtlAmt'
        elif nodeName_ == 'Dtls':
            obj_ = TaxRecordDetails1.factory()
            obj_.build(child_)
            self.Dtls.append(obj_)
            obj_.original_tagname_ = 'Dtls'
# end class TaxAmount1


class TaxAuthorisation1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Titl=None, Nm=None):
        self.original_tagname_ = None
        self.Titl = Titl
        self.validate_Max35Text(self.Titl)
        self.Nm = Nm
        self.validate_Max140Text(self.Nm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxAuthorisation1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxAuthorisation1.subclass:
            return TaxAuthorisation1.subclass(*args_, **kwargs_)
        else:
            return TaxAuthorisation1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Titl(self): return self.Titl
    def set_Titl(self, Titl): self.Titl = Titl
    def get_Nm(self): return self.Nm
    def set_Nm(self, Nm): self.Nm = Nm
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Titl is not None or
            self.Nm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxAuthorisation1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxAuthorisation1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxAuthorisation1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxAuthorisation1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxAuthorisation1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxAuthorisation1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Titl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitl>%s</%sTitl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Titl), input_name='Titl')), namespace_, eol_))
        if self.Nm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNm>%s</%sNm>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Nm), input_name='Nm')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Titl':
            Titl_ = child_.text
            Titl_ = self.gds_validate_string(Titl_, node, 'Titl')
            self.Titl = Titl_
            # validate type Max35Text
            self.validate_Max35Text(self.Titl)
        elif nodeName_ == 'Nm':
            Nm_ = child_.text
            Nm_ = self.gds_validate_string(Nm_, node, 'Nm')
            self.Nm = Nm_
            # validate type Max140Text
            self.validate_Max140Text(self.Nm)
# end class TaxAuthorisation1


class TaxInformation3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cdtr=None, Dbtr=None, AdmstnZn=None, RefNb=None, Mtd=None, TtlTaxblBaseAmt=None, TtlTaxAmt=None, Dt=None, SeqNb=None, Rcrd=None):
        self.original_tagname_ = None
        self.Cdtr = Cdtr
        self.Dbtr = Dbtr
        self.AdmstnZn = AdmstnZn
        self.validate_Max35Text(self.AdmstnZn)
        self.RefNb = RefNb
        self.validate_Max140Text(self.RefNb)
        self.Mtd = Mtd
        self.validate_Max35Text(self.Mtd)
        self.TtlTaxblBaseAmt = TtlTaxblBaseAmt
        self.TtlTaxAmt = TtlTaxAmt
        if isinstance(Dt, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Dt, '%Y-%m-%d').date()
        else:
            initvalue_ = Dt
        self.Dt = initvalue_
        self.SeqNb = SeqNb
        self.validate_Number(self.SeqNb)
        if Rcrd is None:
            self.Rcrd = []
        else:
            self.Rcrd = Rcrd
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxInformation3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxInformation3.subclass:
            return TaxInformation3.subclass(*args_, **kwargs_)
        else:
            return TaxInformation3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cdtr(self): return self.Cdtr
    def set_Cdtr(self, Cdtr): self.Cdtr = Cdtr
    def get_Dbtr(self): return self.Dbtr
    def set_Dbtr(self, Dbtr): self.Dbtr = Dbtr
    def get_AdmstnZn(self): return self.AdmstnZn
    def set_AdmstnZn(self, AdmstnZn): self.AdmstnZn = AdmstnZn
    def get_RefNb(self): return self.RefNb
    def set_RefNb(self, RefNb): self.RefNb = RefNb
    def get_Mtd(self): return self.Mtd
    def set_Mtd(self, Mtd): self.Mtd = Mtd
    def get_TtlTaxblBaseAmt(self): return self.TtlTaxblBaseAmt
    def set_TtlTaxblBaseAmt(self, TtlTaxblBaseAmt): self.TtlTaxblBaseAmt = TtlTaxblBaseAmt
    def get_TtlTaxAmt(self): return self.TtlTaxAmt
    def set_TtlTaxAmt(self, TtlTaxAmt): self.TtlTaxAmt = TtlTaxAmt
    def get_Dt(self): return self.Dt
    def set_Dt(self, Dt): self.Dt = Dt
    def get_SeqNb(self): return self.SeqNb
    def set_SeqNb(self, SeqNb): self.SeqNb = SeqNb
    def get_Rcrd(self): return self.Rcrd
    def set_Rcrd(self, Rcrd): self.Rcrd = Rcrd
    def add_Rcrd(self, value): self.Rcrd.append(value)
    def insert_Rcrd_at(self, index, value): self.Rcrd.insert(index, value)
    def replace_Rcrd_at(self, index, value): self.Rcrd[index] = value
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Number(self, value):
        # Validate type Number, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Number' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Cdtr is not None or
            self.Dbtr is not None or
            self.AdmstnZn is not None or
            self.RefNb is not None or
            self.Mtd is not None or
            self.TtlTaxblBaseAmt is not None or
            self.TtlTaxAmt is not None or
            self.Dt is not None or
            self.SeqNb is not None or
            self.Rcrd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxInformation3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxInformation3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxInformation3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxInformation3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxInformation3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxInformation3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cdtr is not None:
            self.Cdtr.export(outfile, level, namespace_, name_='Cdtr', pretty_print=pretty_print)
        if self.Dbtr is not None:
            self.Dbtr.export(outfile, level, namespace_, name_='Dbtr', pretty_print=pretty_print)
        if self.AdmstnZn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdmstnZn>%s</%sAdmstnZn>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AdmstnZn), input_name='AdmstnZn')), namespace_, eol_))
        if self.RefNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefNb>%s</%sRefNb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RefNb), input_name='RefNb')), namespace_, eol_))
        if self.Mtd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtd>%s</%sMtd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Mtd), input_name='Mtd')), namespace_, eol_))
        if self.TtlTaxblBaseAmt is not None:
            self.TtlTaxblBaseAmt.export(outfile, level, namespace_, name_='TtlTaxblBaseAmt', pretty_print=pretty_print)
        if self.TtlTaxAmt is not None:
            self.TtlTaxAmt.export(outfile, level, namespace_, name_='TtlTaxAmt', pretty_print=pretty_print)
        if self.Dt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDt>%s</%sDt>%s' % (namespace_, self.gds_format_date(self.Dt, input_name='Dt'), namespace_, eol_))
        if self.SeqNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeqNb>%s</%sSeqNb>%s' % (namespace_, self.gds_format_float(self.SeqNb, input_name='SeqNb'), namespace_, eol_))
        for Rcrd_ in self.Rcrd:
            Rcrd_.export(outfile, level, namespace_, name_='Rcrd', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cdtr':
            obj_ = TaxParty1.factory()
            obj_.build(child_)
            self.Cdtr = obj_
            obj_.original_tagname_ = 'Cdtr'
        elif nodeName_ == 'Dbtr':
            obj_ = TaxParty2.factory()
            obj_.build(child_)
            self.Dbtr = obj_
            obj_.original_tagname_ = 'Dbtr'
        elif nodeName_ == 'AdmstnZn':
            AdmstnZn_ = child_.text
            AdmstnZn_ = self.gds_validate_string(AdmstnZn_, node, 'AdmstnZn')
            self.AdmstnZn = AdmstnZn_
            # validate type Max35Text
            self.validate_Max35Text(self.AdmstnZn)
        elif nodeName_ == 'RefNb':
            RefNb_ = child_.text
            RefNb_ = self.gds_validate_string(RefNb_, node, 'RefNb')
            self.RefNb = RefNb_
            # validate type Max140Text
            self.validate_Max140Text(self.RefNb)
        elif nodeName_ == 'Mtd':
            Mtd_ = child_.text
            Mtd_ = self.gds_validate_string(Mtd_, node, 'Mtd')
            self.Mtd = Mtd_
            # validate type Max35Text
            self.validate_Max35Text(self.Mtd)
        elif nodeName_ == 'TtlTaxblBaseAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.TtlTaxblBaseAmt = obj_
            obj_.original_tagname_ = 'TtlTaxblBaseAmt'
        elif nodeName_ == 'TtlTaxAmt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.TtlTaxAmt = obj_
            obj_.original_tagname_ = 'TtlTaxAmt'
        elif nodeName_ == 'Dt':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Dt = dval_
            # validate type ISODate
            self.validate_ISODate(self.Dt)
        elif nodeName_ == 'SeqNb':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SeqNb')
            self.SeqNb = fval_
            # validate type Number
            self.validate_Number(self.SeqNb)
        elif nodeName_ == 'Rcrd':
            obj_ = TaxRecord1.factory()
            obj_.build(child_)
            self.Rcrd.append(obj_)
            obj_.original_tagname_ = 'Rcrd'
# end class TaxInformation3


class TaxParty1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxId=None, RegnId=None, TaxTp=None):
        self.original_tagname_ = None
        self.TaxId = TaxId
        self.validate_Max35Text(self.TaxId)
        self.RegnId = RegnId
        self.validate_Max35Text(self.RegnId)
        self.TaxTp = TaxTp
        self.validate_Max35Text(self.TaxTp)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxParty1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxParty1.subclass:
            return TaxParty1.subclass(*args_, **kwargs_)
        else:
            return TaxParty1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxId(self): return self.TaxId
    def set_TaxId(self, TaxId): self.TaxId = TaxId
    def get_RegnId(self): return self.RegnId
    def set_RegnId(self, RegnId): self.RegnId = RegnId
    def get_TaxTp(self): return self.TaxTp
    def set_TaxTp(self, TaxTp): self.TaxTp = TaxTp
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TaxId is not None or
            self.RegnId is not None or
            self.TaxTp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxParty1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxParty1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxParty1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxParty1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxParty1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxParty1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxId>%s</%sTaxId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TaxId), input_name='TaxId')), namespace_, eol_))
        if self.RegnId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegnId>%s</%sRegnId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RegnId), input_name='RegnId')), namespace_, eol_))
        if self.TaxTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxTp>%s</%sTaxTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TaxTp), input_name='TaxTp')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxId':
            TaxId_ = child_.text
            TaxId_ = self.gds_validate_string(TaxId_, node, 'TaxId')
            self.TaxId = TaxId_
            # validate type Max35Text
            self.validate_Max35Text(self.TaxId)
        elif nodeName_ == 'RegnId':
            RegnId_ = child_.text
            RegnId_ = self.gds_validate_string(RegnId_, node, 'RegnId')
            self.RegnId = RegnId_
            # validate type Max35Text
            self.validate_Max35Text(self.RegnId)
        elif nodeName_ == 'TaxTp':
            TaxTp_ = child_.text
            TaxTp_ = self.gds_validate_string(TaxTp_, node, 'TaxTp')
            self.TaxTp = TaxTp_
            # validate type Max35Text
            self.validate_Max35Text(self.TaxTp)
# end class TaxParty1


class TaxParty2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxId=None, RegnId=None, TaxTp=None, Authstn=None):
        self.original_tagname_ = None
        self.TaxId = TaxId
        self.validate_Max35Text(self.TaxId)
        self.RegnId = RegnId
        self.validate_Max35Text(self.RegnId)
        self.TaxTp = TaxTp
        self.validate_Max35Text(self.TaxTp)
        self.Authstn = Authstn
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxParty2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxParty2.subclass:
            return TaxParty2.subclass(*args_, **kwargs_)
        else:
            return TaxParty2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxId(self): return self.TaxId
    def set_TaxId(self, TaxId): self.TaxId = TaxId
    def get_RegnId(self): return self.RegnId
    def set_RegnId(self, RegnId): self.RegnId = RegnId
    def get_TaxTp(self): return self.TaxTp
    def set_TaxTp(self, TaxTp): self.TaxTp = TaxTp
    def get_Authstn(self): return self.Authstn
    def set_Authstn(self, Authstn): self.Authstn = Authstn
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TaxId is not None or
            self.RegnId is not None or
            self.TaxTp is not None or
            self.Authstn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxParty2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxParty2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxParty2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxParty2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxParty2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxParty2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxId>%s</%sTaxId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TaxId), input_name='TaxId')), namespace_, eol_))
        if self.RegnId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegnId>%s</%sRegnId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RegnId), input_name='RegnId')), namespace_, eol_))
        if self.TaxTp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxTp>%s</%sTaxTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TaxTp), input_name='TaxTp')), namespace_, eol_))
        if self.Authstn is not None:
            self.Authstn.export(outfile, level, namespace_, name_='Authstn', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxId':
            TaxId_ = child_.text
            TaxId_ = self.gds_validate_string(TaxId_, node, 'TaxId')
            self.TaxId = TaxId_
            # validate type Max35Text
            self.validate_Max35Text(self.TaxId)
        elif nodeName_ == 'RegnId':
            RegnId_ = child_.text
            RegnId_ = self.gds_validate_string(RegnId_, node, 'RegnId')
            self.RegnId = RegnId_
            # validate type Max35Text
            self.validate_Max35Text(self.RegnId)
        elif nodeName_ == 'TaxTp':
            TaxTp_ = child_.text
            TaxTp_ = self.gds_validate_string(TaxTp_, node, 'TaxTp')
            self.TaxTp = TaxTp_
            # validate type Max35Text
            self.validate_Max35Text(self.TaxTp)
        elif nodeName_ == 'Authstn':
            obj_ = TaxAuthorisation1.factory()
            obj_.build(child_)
            self.Authstn = obj_
            obj_.original_tagname_ = 'Authstn'
# end class TaxParty2


class TaxPeriod1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Yr=None, Tp=None, FrToDt=None):
        self.original_tagname_ = None
        if isinstance(Yr, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Yr, '%Y-%m-%d').date()
        else:
            initvalue_ = Yr
        self.Yr = initvalue_
        self.Tp = Tp
        self.validate_TaxRecordPeriod1Code(self.Tp)
        self.FrToDt = FrToDt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxPeriod1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxPeriod1.subclass:
            return TaxPeriod1.subclass(*args_, **kwargs_)
        else:
            return TaxPeriod1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Yr(self): return self.Yr
    def set_Yr(self, Yr): self.Yr = Yr
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_FrToDt(self): return self.FrToDt
    def set_FrToDt(self, FrToDt): self.FrToDt = FrToDt
    def validate_ISODate(self, value):
        # Validate type ISODate, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_TaxRecordPeriod1Code(self, value):
        # Validate type TaxRecordPeriod1Code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MM01', 'MM02', 'MM03', 'MM04', 'MM05', 'MM06', 'MM07', 'MM08', 'MM09', 'MM10', 'MM11', 'MM12', 'QTR1', 'QTR2', 'QTR3', 'QTR4', 'HLF1', 'HLF2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TaxRecordPeriod1Code' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Yr is not None or
            self.Tp is not None or
            self.FrToDt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxPeriod1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxPeriod1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxPeriod1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxPeriod1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxPeriod1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxPeriod1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Yr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYr>%s</%sYr>%s' % (namespace_, self.gds_format_date(self.Yr, input_name='Yr'), namespace_, eol_))
        if self.Tp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTp>%s</%sTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Tp), input_name='Tp')), namespace_, eol_))
        if self.FrToDt is not None:
            self.FrToDt.export(outfile, level, namespace_, name_='FrToDt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Yr':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Yr = dval_
            # validate type ISODate
            self.validate_ISODate(self.Yr)
        elif nodeName_ == 'Tp':
            Tp_ = child_.text
            Tp_ = self.gds_validate_string(Tp_, node, 'Tp')
            self.Tp = Tp_
            # validate type TaxRecordPeriod1Code
            self.validate_TaxRecordPeriod1Code(self.Tp)
        elif nodeName_ == 'FrToDt':
            obj_ = DatePeriodDetails.factory()
            obj_.build(child_)
            self.FrToDt = obj_
            obj_.original_tagname_ = 'FrToDt'
# end class TaxPeriod1


class TaxRecord1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tp=None, Ctgy=None, CtgyDtls=None, DbtrSts=None, CertId=None, FrmsCd=None, Prd=None, TaxAmt=None, AddtlInf=None):
        self.original_tagname_ = None
        self.Tp = Tp
        self.validate_Max35Text(self.Tp)
        self.Ctgy = Ctgy
        self.validate_Max35Text(self.Ctgy)
        self.CtgyDtls = CtgyDtls
        self.validate_Max35Text(self.CtgyDtls)
        self.DbtrSts = DbtrSts
        self.validate_Max35Text(self.DbtrSts)
        self.CertId = CertId
        self.validate_Max35Text(self.CertId)
        self.FrmsCd = FrmsCd
        self.validate_Max35Text(self.FrmsCd)
        self.Prd = Prd
        self.TaxAmt = TaxAmt
        self.AddtlInf = AddtlInf
        self.validate_Max140Text(self.AddtlInf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxRecord1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxRecord1.subclass:
            return TaxRecord1.subclass(*args_, **kwargs_)
        else:
            return TaxRecord1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tp(self): return self.Tp
    def set_Tp(self, Tp): self.Tp = Tp
    def get_Ctgy(self): return self.Ctgy
    def set_Ctgy(self, Ctgy): self.Ctgy = Ctgy
    def get_CtgyDtls(self): return self.CtgyDtls
    def set_CtgyDtls(self, CtgyDtls): self.CtgyDtls = CtgyDtls
    def get_DbtrSts(self): return self.DbtrSts
    def set_DbtrSts(self, DbtrSts): self.DbtrSts = DbtrSts
    def get_CertId(self): return self.CertId
    def set_CertId(self, CertId): self.CertId = CertId
    def get_FrmsCd(self): return self.FrmsCd
    def set_FrmsCd(self, FrmsCd): self.FrmsCd = FrmsCd
    def get_Prd(self): return self.Prd
    def set_Prd(self, Prd): self.Prd = Prd
    def get_TaxAmt(self): return self.TaxAmt
    def set_TaxAmt(self, TaxAmt): self.TaxAmt = TaxAmt
    def get_AddtlInf(self): return self.AddtlInf
    def set_AddtlInf(self, AddtlInf): self.AddtlInf = AddtlInf
    def validate_Max35Text(self, value):
        # Validate type Max35Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max35Text' % {"value" : value.encode("utf-8")} )
    def validate_Max140Text(self, value):
        # Validate type Max140Text, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 140:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Max140Text' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Tp is not None or
            self.Ctgy is not None or
            self.CtgyDtls is not None or
            self.DbtrSts is not None or
            self.CertId is not None or
            self.FrmsCd is not None or
            self.Prd is not None or
            self.TaxAmt is not None or
            self.AddtlInf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxRecord1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxRecord1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxRecord1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxRecord1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxRecord1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxRecord1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTp>%s</%sTp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Tp), input_name='Tp')), namespace_, eol_))
        if self.Ctgy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtgy>%s</%sCtgy>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ctgy), input_name='Ctgy')), namespace_, eol_))
        if self.CtgyDtls is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCtgyDtls>%s</%sCtgyDtls>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CtgyDtls), input_name='CtgyDtls')), namespace_, eol_))
        if self.DbtrSts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDbtrSts>%s</%sDbtrSts>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DbtrSts), input_name='DbtrSts')), namespace_, eol_))
        if self.CertId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCertId>%s</%sCertId>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CertId), input_name='CertId')), namespace_, eol_))
        if self.FrmsCd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFrmsCd>%s</%sFrmsCd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FrmsCd), input_name='FrmsCd')), namespace_, eol_))
        if self.Prd is not None:
            self.Prd.export(outfile, level, namespace_, name_='Prd', pretty_print=pretty_print)
        if self.TaxAmt is not None:
            self.TaxAmt.export(outfile, level, namespace_, name_='TaxAmt', pretty_print=pretty_print)
        if self.AddtlInf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddtlInf>%s</%sAddtlInf>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AddtlInf), input_name='AddtlInf')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tp':
            Tp_ = child_.text
            Tp_ = self.gds_validate_string(Tp_, node, 'Tp')
            self.Tp = Tp_
            # validate type Max35Text
            self.validate_Max35Text(self.Tp)
        elif nodeName_ == 'Ctgy':
            Ctgy_ = child_.text
            Ctgy_ = self.gds_validate_string(Ctgy_, node, 'Ctgy')
            self.Ctgy = Ctgy_
            # validate type Max35Text
            self.validate_Max35Text(self.Ctgy)
        elif nodeName_ == 'CtgyDtls':
            CtgyDtls_ = child_.text
            CtgyDtls_ = self.gds_validate_string(CtgyDtls_, node, 'CtgyDtls')
            self.CtgyDtls = CtgyDtls_
            # validate type Max35Text
            self.validate_Max35Text(self.CtgyDtls)
        elif nodeName_ == 'DbtrSts':
            DbtrSts_ = child_.text
            DbtrSts_ = self.gds_validate_string(DbtrSts_, node, 'DbtrSts')
            self.DbtrSts = DbtrSts_
            # validate type Max35Text
            self.validate_Max35Text(self.DbtrSts)
        elif nodeName_ == 'CertId':
            CertId_ = child_.text
            CertId_ = self.gds_validate_string(CertId_, node, 'CertId')
            self.CertId = CertId_
            # validate type Max35Text
            self.validate_Max35Text(self.CertId)
        elif nodeName_ == 'FrmsCd':
            FrmsCd_ = child_.text
            FrmsCd_ = self.gds_validate_string(FrmsCd_, node, 'FrmsCd')
            self.FrmsCd = FrmsCd_
            # validate type Max35Text
            self.validate_Max35Text(self.FrmsCd)
        elif nodeName_ == 'Prd':
            obj_ = TaxPeriod1.factory()
            obj_.build(child_)
            self.Prd = obj_
            obj_.original_tagname_ = 'Prd'
        elif nodeName_ == 'TaxAmt':
            obj_ = TaxAmount1.factory()
            obj_.build(child_)
            self.TaxAmt = obj_
            obj_.original_tagname_ = 'TaxAmt'
        elif nodeName_ == 'AddtlInf':
            AddtlInf_ = child_.text
            AddtlInf_ = self.gds_validate_string(AddtlInf_, node, 'AddtlInf')
            self.AddtlInf = AddtlInf_
            # validate type Max140Text
            self.validate_Max140Text(self.AddtlInf)
# end class TaxRecord1


class TaxRecordDetails1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Prd=None, Amt=None):
        self.original_tagname_ = None
        self.Prd = Prd
        self.Amt = Amt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxRecordDetails1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxRecordDetails1.subclass:
            return TaxRecordDetails1.subclass(*args_, **kwargs_)
        else:
            return TaxRecordDetails1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prd(self): return self.Prd
    def set_Prd(self, Prd): self.Prd = Prd
    def get_Amt(self): return self.Amt
    def set_Amt(self, Amt): self.Amt = Amt
    def hasContent_(self):
        if (
            self.Prd is not None or
            self.Amt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaxRecordDetails1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxRecordDetails1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxRecordDetails1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaxRecordDetails1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaxRecordDetails1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TaxRecordDetails1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prd is not None:
            self.Prd.export(outfile, level, namespace_, name_='Prd', pretty_print=pretty_print)
        if self.Amt is not None:
            self.Amt.export(outfile, level, namespace_, name_='Amt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prd':
            obj_ = TaxPeriod1.factory()
            obj_.build(child_)
            self.Prd = obj_
            obj_.original_tagname_ = 'Prd'
        elif nodeName_ == 'Amt':
            obj_ = ActiveOrHistoricCurrencyAndAmount.factory()
            obj_.build(child_)
            self.Amt = obj_
            obj_.original_tagname_ = 'Amt'
# end class TaxRecordDetails1


GDSClassesMapping = {
    'AdjstmntAmtAndRsn': DocumentAdjustment1,
    'Adr': PostalAddress6,
    'Amt': ActiveOrHistoricCurrencyAndAmount,
    'Authrty': RegulatoryAuthority2,
    'Authstn': TaxAuthorisation1,
    'BrnchId': BranchData2,
    'CdOrPrtry': ReferredDocumentType1Choice,
    'CdtNoteAmt': ActiveOrHistoricCurrencyAndAmount,
    'CdtTrfTxInf': CreditTransferTransactionInformation10,
    'Cdtr': TaxParty1,
    'CdtrAcct': CashAccount16,
    'CdtrAgt': BranchAndFinancialInstitutionIdentification4,
    'CdtrAgtAcct': CashAccount16,
    'CdtrRefInf': CreditorReferenceInformation2,
    'ChqFr': NameAndAddress10,
    'ChqInstr': Cheque6,
    'ChrgsAcct': CashAccount16,
    'ChrgsAcctAgt': BranchAndFinancialInstitutionIdentification4,
    'ClrSysId': ClearingSystemIdentification2Choice,
    'ClrSysMmbId': ClearingSystemMemberIdentification2,
    'CstmrCdtTrfInitn': CustomerCreditTransferInitiationV03,
    'CtctDtls': ContactDetails2,
    'CtgyPurp': CategoryPurpose1Choice,
    'Dbtr': TaxParty2,
    'DbtrAcct': CashAccount16,
    'DbtrAgt': BranchAndFinancialInstitutionIdentification4,
    'DbtrAgtAcct': CashAccount16,
    'DlvrTo': NameAndAddress10,
    'DlvryMtd': ChequeDeliveryMethod1Choice,
    'DscntApldAmt': ActiveOrHistoricCurrencyAndAmount,
    'DtAndPlcOfBirth': DateAndPlaceOfBirth,
    'Dtls': TaxRecordDetails1,
    'DuePyblAmt': ActiveOrHistoricCurrencyAndAmount,
    'EqvtAmt': EquivalentAmount2,
    'FinInstnId': FinancialInstitutionIdentification7,
    'FrToDt': DatePeriodDetails,
    'FwdgAgt': BranchAndFinancialInstitutionIdentification4,
    'GrpHdr': GroupHeader32,
    'Id': Party6Choice,
    'InitgPty': PartyIdentification32,
    'InstdAmt': ActiveOrHistoricCurrencyAndAmount,
    'InstrForCdtrAgt': InstructionForCreditorAgent1,
    'IntrmyAgt1': BranchAndFinancialInstitutionIdentification4,
    'IntrmyAgt1Acct': CashAccount16,
    'IntrmyAgt2': BranchAndFinancialInstitutionIdentification4,
    'IntrmyAgt2Acct': CashAccount16,
    'IntrmyAgt3': BranchAndFinancialInstitutionIdentification4,
    'IntrmyAgt3Acct': CashAccount16,
    'Invcee': PartyIdentification32,
    'Invcr': PartyIdentification32,
    'LclInstrm': LocalInstrument2Choice,
    'OrgId': OrganisationIdentification4,
    'Othr': GenericPersonIdentification1,
    'PmtId': PaymentIdentification1,
    'PmtInf': PaymentInstructionInformation3,
    'PmtTpInf': PaymentTypeInformation19,
    'Prd': TaxPeriod1,
    'PrvtId': PersonIdentification5,
    'PstlAdr': PostalAddress6,
    'Purp': Purpose2Choice,
    'Rcrd': TaxRecord1,
    'RfrdDocAmt': RemittanceAmount1,
    'RfrdDocInf': ReferredDocumentInformation3,
    'RgltryRptg': RegulatoryReporting3,
    'RltdRmtInf': RemittanceLocation2,
    'RmtInf': RemittanceInformation5,
    'RmtLctnPstlAdr': NameAndAddress10,
    'RmtdAmt': ActiveOrHistoricCurrencyAndAmount,
    'SchmeNm': PersonIdentificationSchemeName1Choice,
    'Strd': StructuredRemittanceInformation7,
    'SvcLvl': ServiceLevel8Choice,
    'Tax': TaxInformation3,
    'TaxAmt': TaxAmount1,
    'TaxblBaseAmt': ActiveOrHistoricCurrencyAndAmount,
    'Tp': ReferredDocumentType2,
    'TtlAmt': ActiveOrHistoricCurrencyAndAmount,
    'TtlTaxAmt': ActiveOrHistoricCurrencyAndAmount,
    'TtlTaxblBaseAmt': ActiveOrHistoricCurrencyAndAmount,
    'UltmtCdtr': PartyIdentification32,
    'UltmtDbtr': PartyIdentification32,
    'XchgRateInf': ExchangeRateInformation1,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Document'
        rootClass = Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from api import *\n\n')
        sys.stdout.write('import api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccountIdentification4Choice",
    "AccountSchemeName1Choice",
    "ActiveOrHistoricCurrencyAndAmount",
    "AmountType3Choice",
    "Authorisation1Choice",
    "BranchAndFinancialInstitutionIdentification4",
    "BranchData2",
    "CashAccount16",
    "CashAccountType2",
    "CategoryPurpose1Choice",
    "Cheque6",
    "ChequeDeliveryMethod1Choice",
    "ClearingSystemIdentification2Choice",
    "ClearingSystemMemberIdentification2",
    "ContactDetails2",
    "CreditTransferTransactionInformation10",
    "CreditorReferenceInformation2",
    "CreditorReferenceType1Choice",
    "CreditorReferenceType2",
    "CustomerCreditTransferInitiationV03",
    "DateAndPlaceOfBirth",
    "DatePeriodDetails",
    "Document",
    "DocumentAdjustment1",
    "EquivalentAmount2",
    "ExchangeRateInformation1",
    "FinancialIdentificationSchemeName1Choice",
    "FinancialInstitutionIdentification7",
    "GenericAccountIdentification1",
    "GenericFinancialIdentification1",
    "GenericOrganisationIdentification1",
    "GenericPersonIdentification1",
    "GroupHeader32",
    "InstructionForCreditorAgent1",
    "LocalInstrument2Choice",
    "NameAndAddress10",
    "OrganisationIdentification4",
    "OrganisationIdentificationSchemeName1Choice",
    "Party6Choice",
    "PartyIdentification32",
    "PaymentIdentification1",
    "PaymentInstructionInformation3",
    "PaymentTypeInformation19",
    "PersonIdentification5",
    "PersonIdentificationSchemeName1Choice",
    "PostalAddress6",
    "Purpose2Choice",
    "ReferredDocumentInformation3",
    "ReferredDocumentType1Choice",
    "ReferredDocumentType2",
    "RegulatoryAuthority2",
    "RegulatoryReporting3",
    "RemittanceAmount1",
    "RemittanceInformation5",
    "RemittanceLocation2",
    "ServiceLevel8Choice",
    "StructuredRegulatoryReporting3",
    "StructuredRemittanceInformation7",
    "TaxAmount1",
    "TaxAuthorisation1",
    "TaxInformation3",
    "TaxParty1",
    "TaxParty2",
    "TaxPeriod1",
    "TaxRecord1",
    "TaxRecordDetails1"
]
